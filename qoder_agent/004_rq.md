# 分页功能完整实现方案

## 1. 需求概述

### 1.1 目标组件
为以下四个组件实现完整的分页功能：
1. `data-agent-frontend/src/components/agent/BusinessKnowledgeConfig.vue` - 业务知识管理
2. `data-agent-frontend/src/components/agent/DataSourceConfig.vue` - 数据源配置
3. `data-agent-frontend/src/components/agent/SemanticsConfig.vue` - 语义模型管理
4. `data-agent-frontend/src/views/AgentList.vue` - 智能体列表

### 1.2 参考实现
- `PresetsConfig.vue` - 预设问题管理（已实现分页）
- `Pagination.vue` - 通用分页组件（可复用）
- `presetQuestion.ts` - 分页服务接口（可参考）

### 1.3 现有可复用组件
- **Pagination组件**: `data-agent-frontend/src/components/common/Pagination.vue`
- **PageResponse接口**: `data-agent-frontend/src/services/common.ts`
- **后端PageResult类**: `data-agent-management/.../vo/PageResult.java`
- **后端PageResponse类**: `data-agent-management/.../vo/PageResponse.java`

---

## 2. 公共代码提取

### 2.1 前端通用分页查询参数接口

**文件**: `data-agent-frontend/src/services/common.ts` (新增)

```typescript
// 通用分页查询参数基类
export interface BasePageQueryParams {
  pageNum: number;
  pageSize: number;
}

// 带关键词搜索的分页查询参数
export interface KeywordPageQueryParams extends BasePageQueryParams {
  keyword?: string;
}

// 带状态筛选的分页查询参数
export interface StatusPageQueryParams extends KeywordPageQueryParams {
  status?: number | boolean;
}

// 带日期范围的分页查询参数
export interface DateRangePageQueryParams extends StatusPageQueryParams {
  createTimeStart?: string;
  createTimeEnd?: string;
}
```

### 2.2 后端通用分页查询DTO基类

**文件**: `data-agent-management/.../dto/common/BasePageQueryDTO.java` (新增)

```java
package com.audaque.cloud.ai.dataagent.dto.common;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class BasePageQueryDTO {
    
    @NotNull(message = "pageNum cannot be null")
    @Min(value = 1, message = "pageNum must be greater than 0")
    private Integer pageNum = 1;

    @NotNull(message = "pageSize cannot be null")
    @Min(value = 1, message = "pageSize must be greater than 0")
    @Max(value = 100, message = "pageSize cannot exceed 100")
    private Integer pageSize = 10;
    
    /**
     * Calculate offset for pagination
     */
    public int calculateOffset() {
        return (pageNum - 1) * pageSize;
    }
}
```

### 2.3 前端通用分页状态管理 Hook

**文件**: `data-agent-frontend/src/composables/usePagination.ts` (新增)

```typescript
import { ref, Ref, reactive } from 'vue';

export interface PaginationState {
  pageNum: number;
  pageSize: number;
  total: number;
}

export interface UsePaginationOptions {
  defaultPageSize?: number;
  defaultPageNum?: number;
}

export function usePagination(options: UsePaginationOptions = {}) {
  const pagination = reactive<PaginationState>({
    pageNum: options.defaultPageNum || 1,
    pageSize: options.defaultPageSize || 10,
    total: 0,
  });

  const resetToFirstPage = () => {
    pagination.pageNum = 1;
  };

  const updateTotal = (total: number) => {
    pagination.total = total;
  };

  return {
    pagination,
    resetToFirstPage,
    updateTotal,
  };
}
```

---

## 3. 业务知识管理 (BusinessKnowledgeConfig.vue) 分页实现

### 3.1 后端实现

#### 3.1.1 创建分页查询DTO

**文件**: `data-agent-management/.../dto/knowledge/BusinessKnowledgeQueryDTO.java` (新增)

```java
package com.audaque.cloud.ai.dataagent.dto.knowledge;

import com.audaque.cloud.ai.dataagent.dto.common.BasePageQueryDTO;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class BusinessKnowledgeQueryDTO extends BasePageQueryDTO {
    
    private Long agentId;
    
    // Fuzzy search by business term, description, or synonyms
    private String keyword;
    
    // Filter by recall status: null-all, true-recalled, false-not recalled
    private Boolean isRecall;
    
    // Filter by embedding status: PENDING, PROCESSING, COMPLETED, FAILED
    private String embeddingStatus;
    
    // Date range filter
    private String createTimeStart;
    private String createTimeEnd;
}
```

#### 3.1.2 扩展Mapper接口

**文件**: `data-agent-management/.../mapper/BusinessKnowledgeMapper.java` (修改)

```java
// Add new methods

/**
 * Page query business knowledge with filters
 */
@Select("""
    <script>
    SELECT * FROM business_knowledge
    WHERE agent_id = #{queryDTO.agentId} AND is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (business_term LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR description LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR synonyms LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.isRecall != null">
        AND is_recall = #{queryDTO.isRecall}
    </if>
    <if test="queryDTO.embeddingStatus != null and queryDTO.embeddingStatus != ''">
        AND embedding_status = #{queryDTO.embeddingStatus}
    </if>
    <if test="queryDTO.createTimeStart != null and queryDTO.createTimeStart != ''">
        AND created_time &gt;= #{queryDTO.createTimeStart}
    </if>
    <if test="queryDTO.createTimeEnd != null and queryDTO.createTimeEnd != ''">
        AND created_time &lt;= #{queryDTO.createTimeEnd}
    </if>
    ORDER BY created_time DESC
    ${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, queryDTO.pageSize)}
    </script>
    """)
List<BusinessKnowledge> selectByConditionsWithPage(
    @Param("queryDTO") BusinessKnowledgeQueryDTO queryDTO,
    @Param("offset") Integer offset);

/**
 * Count total records by conditions
 */
@Select("""
    <script>
    SELECT COUNT(*) FROM business_knowledge
    WHERE agent_id = #{queryDTO.agentId} AND is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (business_term LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR description LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR synonyms LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.isRecall != null">
        AND is_recall = #{queryDTO.isRecall}
    </if>
    <if test="queryDTO.embeddingStatus != null and queryDTO.embeddingStatus != ''">
        AND embedding_status = #{queryDTO.embeddingStatus}
    </if>
    <if test="queryDTO.createTimeStart != null and queryDTO.createTimeStart != ''">
        AND created_time &gt;= #{queryDTO.createTimeStart}
    </if>
    <if test="queryDTO.createTimeEnd != null and queryDTO.createTimeEnd != ''">
        AND created_time &lt;= #{queryDTO.createTimeEnd}
    </if>
    </script>
    """)
Long countByConditions(@Param("queryDTO") BusinessKnowledgeQueryDTO queryDTO);
```

#### 3.1.3 扩展Service接口和实现

**文件**: `data-agent-management/.../service/knowledge/BusinessKnowledgeService.java` (修改)

```java
// Add new method
PageResult<BusinessKnowledgeVO> queryByConditionsWithPage(BusinessKnowledgeQueryDTO queryDTO);
```

**文件**: `data-agent-management/.../service/knowledge/BusinessKnowledgeServiceImpl.java` (修改)

```java
@Override
public PageResult<BusinessKnowledgeVO> queryByConditionsWithPage(BusinessKnowledgeQueryDTO queryDTO) {
    log.info("Page query business knowledge: agentId={}, pageNum={}, pageSize={}, keyword={}",
            queryDTO.getAgentId(), queryDTO.getPageNum(), queryDTO.getPageSize(), queryDTO.getKeyword());

    if (queryDTO.getAgentId() == null) {
        throw new IllegalArgumentException("agentId cannot be null");
    }

    int offset = queryDTO.calculateOffset();
    
    Long total = businessKnowledgeMapper.countByConditions(queryDTO);
    List<BusinessKnowledge> dataList = businessKnowledgeMapper.selectByConditionsWithPage(queryDTO, offset);
    
    // Convert to VO
    List<BusinessKnowledgeVO> voList = dataList.stream()
            .map(this::convertToVO)
            .collect(Collectors.toList());

    PageResult<BusinessKnowledgeVO> pageResult = new PageResult<>();
    pageResult.setData(voList);
    pageResult.setTotal(total);
    pageResult.setPageNum(queryDTO.getPageNum());
    pageResult.setPageSize(queryDTO.getPageSize());
    pageResult.calculateTotalPages();

    return pageResult;
}
```

#### 3.1.4 扩展Controller

**文件**: `data-agent-management/.../controller/BusinessKnowledgeController.java` (修改)

```java
/**
 * Page query business knowledge with filters
 */
@PostMapping("/page")
public PageResponse<List<BusinessKnowledgeVO>> queryByPage(
        @Valid @RequestBody BusinessKnowledgeQueryDTO queryDTO) {
    try {
        log.info("Page query request: agentId={}, pageNum={}, pageSize={}",
                queryDTO.getAgentId(), queryDTO.getPageNum(), queryDTO.getPageSize());

        PageResult<BusinessKnowledgeVO> pageResult = businessKnowledgeService.queryByConditionsWithPage(queryDTO);

        return PageResponse.success(pageResult.getData(), pageResult.getTotal(),
                pageResult.getPageNum(), pageResult.getPageSize(), pageResult.getTotalPages());
    } catch (IllegalArgumentException e) {
        log.error("Invalid query parameters: {}", e.getMessage());
        return PageResponse.pageError("Invalid parameters: " + e.getMessage());
    } catch (Exception e) {
        log.error("Error querying business knowledge page", e);
        return PageResponse.pageError("Query failed: " + e.getMessage());
    }
}
```

### 3.2 前端实现

#### 3.2.1 扩展服务接口

**文件**: `data-agent-frontend/src/services/businessKnowledge.ts` (修改)

```typescript
import { PageResponse } from './common';

// Add new interface
interface BusinessKnowledgeQueryParams {
  agentId: number;
  pageNum: number;
  pageSize: number;
  keyword?: string;
  isRecall?: boolean;
  embeddingStatus?: string;
  createTimeStart?: string;
  createTimeEnd?: string;
}

// Add new method to service class
/**
 * 分页查询业务知识
 * @param params 查询参数
 */
async queryPage(params: BusinessKnowledgeQueryParams): Promise<PageResponse<BusinessKnowledgeVO[]>> {
  try {
    const response = await axios.post<PageResponse<BusinessKnowledgeVO[]>>(
      `${API_BASE_URL}/page`,
      params,
    );
    return response.data;
  } catch (error) {
    console.error('Query business knowledge page failed:', error);
    throw error;
  }
}

// Export the new interface
export type { BusinessKnowledgeVO, CreateBusinessKnowledgeDTO, UpdateBusinessKnowledgeDTO, BusinessKnowledgeQueryParams };
```

#### 3.2.2 修改组件

**文件**: `data-agent-frontend/src/components/agent/BusinessKnowledgeConfig.vue` (修改)

**Template部分 - 添加搜索表单和分页组件**:

```vue
<template>
  <div style="padding: 20px">
    <div style="margin-bottom: 20px">
      <h2>业务知识管理</h2>
    </div>
    <el-divider />

    <!-- 搜索和筛选区域 -->
    <el-form :inline="true" :model="searchForm" style="margin-bottom: 20px">
      <el-form-item label="关键词">
        <el-input
          v-model="searchForm.keyword"
          placeholder="搜索业务名词/描述/同义词"
          clearable
          @clear="handleSearch"
          @keyup.enter="handleSearch"
          style="width: 250px"
        />
      </el-form-item>
      <el-form-item label="召回状态">
        <el-select
          v-model="searchForm.isRecall"
          placeholder="全部"
          clearable
          style="width: 120px"
        >
          <el-option label="是" :value="true" />
          <el-option label="否" :value="false" />
        </el-select>
      </el-form-item>
      <el-form-item label="向量化状态">
        <el-select
          v-model="searchForm.embeddingStatus"
          placeholder="全部"
          clearable
          style="width: 120px"
        >
          <el-option label="待处理" value="PENDING" />
          <el-option label="处理中" value="PROCESSING" />
          <el-option label="已完成" value="COMPLETED" />
          <el-option label="失败" value="FAILED" />
        </el-select>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="handleSearch">搜索</el-button>
        <el-button @click="handleReset">重置</el-button>
      </el-form-item>
    </el-form>

    <!-- 操作按钮区域 -->
    <div style="margin-bottom: 30px">
      <!-- ... existing buttons ... -->
    </div>

    <!-- 数据表格 -->
    <el-table :data="businessKnowledgeList" style="width: 100%" border>
      <!-- ... existing columns ... -->
    </el-table>

    <!-- 分页组件 -->
    <Pagination
      v-model:page-num="pagination.pageNum"
      v-model:page-size="pagination.pageSize"
      :total="pagination.total"
      :page-sizes="[10, 20, 50, 100]"
      @change="loadBusinessKnowledge"
    />
  </div>
  <!-- ... existing dialogs ... -->
</template>
```

**Script部分 - 添加分页逻辑**:

```typescript
import Pagination from '@/components/common/Pagination.vue';
import { BusinessKnowledgeQueryParams } from '@/services/businessKnowledge';

// In setup()
// Search form
const searchForm = ref({
  keyword: '',
  isRecall: null as boolean | null,
  embeddingStatus: '' as string,
});

// Pagination
const pagination = ref({
  pageNum: 1,
  pageSize: 10,
  total: 0,
});

// Modified load function
const loadBusinessKnowledge = async () => {
  try {
    const params: BusinessKnowledgeQueryParams = {
      agentId: props.agentId,
      pageNum: pagination.value.pageNum,
      pageSize: pagination.value.pageSize,
      keyword: searchForm.value.keyword || undefined,
      isRecall: searchForm.value.isRecall ?? undefined,
      embeddingStatus: searchForm.value.embeddingStatus || undefined,
    };

    const response = await businessKnowledgeService.queryPage(params);

    if (response.success) {
      businessKnowledgeList.value = response.data;
      pagination.value.total = response.total;
    } else {
      ElMessage.error(response.message || '加载业务知识列表失败');
    }
  } catch (error) {
    ElMessage.error('加载业务知识列表失败');
    console.error('Load business knowledge failed:', error);
  }
};

const handleSearch = () => {
  pagination.value.pageNum = 1;
  loadBusinessKnowledge();
};

const handleReset = () => {
  searchForm.value = {
    keyword: '',
    isRecall: null,
    embeddingStatus: '',
  };
  handleSearch();
};

// Return in setup
return {
  // ... existing returns ...
  searchForm,
  pagination,
  handleSearch,
  handleReset,
};
```

---

## 4. 数据源配置 (DataSourceConfig.vue) 分页实现

### 4.1 后端实现

#### 4.1.1 创建分页查询DTO

**文件**: `data-agent-management/.../dto/datasource/DatasourceQueryDTO.java` (新增)

```java
package com.audaque.cloud.ai.dataagent.dto.datasource;

import com.audaque.cloud.ai.dataagent.dto.common.BasePageQueryDTO;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class DatasourceQueryDTO extends BasePageQueryDTO {
    
    // Fuzzy search by name or description
    private String keyword;
    
    // Filter by type: mysql, postgresql, sqlserver, dameng
    private String type;
    
    // Filter by status: active, inactive
    private String status;
}
```

#### 4.1.2 扩展Mapper接口

**文件**: `data-agent-management/.../mapper/DatasourceMapper.java` (修改)

```java
/**
 * Page query datasources with filters
 */
@Select("""
    <script>
    SELECT * FROM datasource
    WHERE is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR description LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.type != null and queryDTO.type != ''">
        AND type = #{queryDTO.type}
    </if>
    <if test="queryDTO.status != null and queryDTO.status != ''">
        AND status = #{queryDTO.status}
    </if>
    ORDER BY create_time DESC
    ${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, queryDTO.pageSize)}
    </script>
    """)
List<Datasource> selectByConditionsWithPage(
    @Param("queryDTO") DatasourceQueryDTO queryDTO,
    @Param("offset") Integer offset);

/**
 * Count total records by conditions
 */
@Select("""
    <script>
    SELECT COUNT(*) FROM datasource
    WHERE is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR description LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.type != null and queryDTO.type != ''">
        AND type = #{queryDTO.type}
    </if>
    <if test="queryDTO.status != null and queryDTO.status != ''">
        AND status = #{queryDTO.status}
    </if>
    </script>
    """)
Long countByConditions(@Param("queryDTO") DatasourceQueryDTO queryDTO);
```

#### 4.1.3 扩展Service和Controller

**文件**: `data-agent-management/.../service/datasource/DatasourceService.java` (修改)

```java
PageResult<Datasource> queryByConditionsWithPage(DatasourceQueryDTO queryDTO);
```

**文件**: `data-agent-management/.../controller/DatasourceController.java` (修改)

```java
/**
 * Page query datasources with filters
 */
@PostMapping("/page")
public PageResponse<List<Datasource>> queryByPage(
        @Valid @RequestBody DatasourceQueryDTO queryDTO) {
    try {
        PageResult<Datasource> pageResult = datasourceService.queryByConditionsWithPage(queryDTO);
        return PageResponse.success(pageResult.getData(), pageResult.getTotal(),
                pageResult.getPageNum(), pageResult.getPageSize(), pageResult.getTotalPages());
    } catch (Exception e) {
        log.error("Error querying datasource page", e);
        return PageResponse.pageError("Query failed: " + e.getMessage());
    }
}
```

### 4.2 前端实现

#### 4.2.1 扩展服务接口

**文件**: `data-agent-frontend/src/services/datasource.ts` (修改)

```typescript
import { PageResponse } from './common';

// Add new interface
export interface DatasourceQueryParams {
  pageNum: number;
  pageSize: number;
  keyword?: string;
  type?: string;
  status?: string;
}

// Add new method to service class
async queryPage(params: DatasourceQueryParams): Promise<PageResponse<Datasource[]>> {
  try {
    const response = await axios.post<PageResponse<Datasource[]>>(
      `${API_BASE_URL}/page`,
      params,
    );
    return response.data;
  } catch (error) {
    console.error('Query datasource page failed:', error);
    throw error;
  }
}
```

#### 4.2.2 修改组件

**注意**: DataSourceConfig.vue 需要在两个表格处添加分页：
1. 当前Agent关联的数据源列表 (主表格)
2. 选择已有数据源弹窗中的表格

**Template部分修改** (选择已有数据源弹窗):

```vue
<el-tab-pane label="选择已有数据源" name="select">
  <!-- 搜索区域 -->
  <el-form :inline="true" style="margin-bottom: 15px">
    <el-form-item>
      <el-input
        v-model="datasourceSearchKeyword"
        placeholder="搜索数据源名称"
        clearable
        @clear="loadAllDatasourceWithPage"
        @keyup.enter="loadAllDatasourceWithPage"
        style="width: 200px"
      />
    </el-form-item>
    <el-form-item>
      <el-select v-model="datasourceSearchType" placeholder="类型" clearable style="width: 120px">
        <el-option label="MySQL" value="mysql" />
        <el-option label="PostgreSQL" value="postgresql" />
        <el-option label="SQL Server" value="sqlserver" />
        <el-option label="达梦" value="dameng" />
      </el-select>
    </el-form-item>
    <el-form-item>
      <el-button type="primary" @click="loadAllDatasourceWithPage">搜索</el-button>
    </el-form-item>
  </el-form>

  <el-table ... >
    <!-- existing columns -->
  </el-table>

  <!-- 分页组件 -->
  <Pagination
    v-model:page-num="datasourcePagination.pageNum"
    v-model:page-size="datasourcePagination.pageSize"
    :total="datasourcePagination.total"
    :page-sizes="[10, 20, 50]"
    @change="loadAllDatasourceWithPage"
  />
  
  <!-- ... rest of content ... -->
</el-tab-pane>
```

**Script部分修改**:

```typescript
// Add new state
const datasourceSearchKeyword: Ref<string> = ref('');
const datasourceSearchType: Ref<string> = ref('');
const datasourcePagination = ref({
  pageNum: 1,
  pageSize: 10,
  total: 0,
});

// New load function with pagination
const loadAllDatasourceWithPage = async () => {
  try {
    const params: DatasourceQueryParams = {
      pageNum: datasourcePagination.value.pageNum,
      pageSize: datasourcePagination.value.pageSize,
      keyword: datasourceSearchKeyword.value || undefined,
      type: datasourceSearchType.value || undefined,
    };

    const response = await datasourceService.queryPage(params);

    if (response.success) {
      allDatasource.value = response.data;
      datasourcePagination.value.total = response.total;
    } else {
      ElMessage.error(response.message || '加载数据源列表失败');
    }
  } catch (error) {
    ElMessage.error('加载数据源列表失败');
    console.error('Failed to load all datasource:', error);
  }
};

// Modify watch for dialog
watch(dialogVisible, newValue => {
  if (newValue) {
    datasourcePagination.value.pageNum = 1;
    loadAllDatasourceWithPage();
    newDatasource.value = { port: 3306 } as Datasource;
  }
});
```

---

## 5. 语义模型管理 (SemanticsConfig.vue) 分页实现

### 5.1 后端实现

#### 5.1.1 创建分页查询DTO

**文件**: `data-agent-management/.../dto/semantic/SemanticModelQueryDTO.java` (新增)

```java
package com.audaque.cloud.ai.dataagent.dto.semantic;

import com.audaque.cloud.ai.dataagent.dto.common.BasePageQueryDTO;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class SemanticModelQueryDTO extends BasePageQueryDTO {
    
    private Long agentId;
    
    // Fuzzy search by table name, column name, business name, or synonyms
    private String keyword;
    
    // Filter by table name
    private String tableName;
    
    // Filter by status: 0-disabled, 1-enabled
    private Integer status;
    
    // Date range filter
    private String createTimeStart;
    private String createTimeEnd;
}
```

#### 5.1.2 扩展Mapper接口

**文件**: `data-agent-management/.../mapper/SemanticModelMapper.java` (修改)

```java
/**
 * Page query semantic models with filters
 */
@Select("""
    <script>
    SELECT * FROM semantic_model
    WHERE agent_id = #{queryDTO.agentId} AND is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (table_name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR column_name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR business_name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR synonyms LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.tableName != null and queryDTO.tableName != ''">
        AND table_name = #{queryDTO.tableName}
    </if>
    <if test="queryDTO.status != null">
        AND status = #{queryDTO.status}
    </if>
    <if test="queryDTO.createTimeStart != null and queryDTO.createTimeStart != ''">
        AND created_time &gt;= #{queryDTO.createTimeStart}
    </if>
    <if test="queryDTO.createTimeEnd != null and queryDTO.createTimeEnd != ''">
        AND created_time &lt;= #{queryDTO.createTimeEnd}
    </if>
    ORDER BY created_time DESC
    ${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, queryDTO.pageSize)}
    </script>
    """)
List<SemanticModel> selectByConditionsWithPage(
    @Param("queryDTO") SemanticModelQueryDTO queryDTO,
    @Param("offset") Integer offset);

/**
 * Count total records by conditions
 */
@Select("""
    <script>
    SELECT COUNT(*) FROM semantic_model
    WHERE agent_id = #{queryDTO.agentId} AND is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (table_name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR column_name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR business_name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR synonyms LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.tableName != null and queryDTO.tableName != ''">
        AND table_name = #{queryDTO.tableName}
    </if>
    <if test="queryDTO.status != null">
        AND status = #{queryDTO.status}
    </if>
    <if test="queryDTO.createTimeStart != null and queryDTO.createTimeStart != ''">
        AND created_time &gt;= #{queryDTO.createTimeStart}
    </if>
    <if test="queryDTO.createTimeEnd != null and queryDTO.createTimeEnd != ''">
        AND created_time &lt;= #{queryDTO.createTimeEnd}
    </if>
    </script>
    """)
Long countByConditions(@Param("queryDTO") SemanticModelQueryDTO queryDTO);
```

#### 5.1.3 扩展Service和Controller

**文件**: `data-agent-management/.../service/semantic/SemanticModelService.java` (修改)

```java
PageResult<SemanticModel> queryByConditionsWithPage(SemanticModelQueryDTO queryDTO);
```

**文件**: `data-agent-management/.../controller/SemanticModelController.java` (修改)

```java
/**
 * Page query semantic models with filters
 */
@PostMapping("/page")
public PageResponse<List<SemanticModel>> queryByPage(
        @Valid @RequestBody SemanticModelQueryDTO queryDTO) {
    try {
        PageResult<SemanticModel> pageResult = semanticModelService.queryByConditionsWithPage(queryDTO);
        return PageResponse.success(pageResult.getData(), pageResult.getTotal(),
                pageResult.getPageNum(), pageResult.getPageSize(), pageResult.getTotalPages());
    } catch (Exception e) {
        log.error("Error querying semantic model page", e);
        return PageResponse.pageError("Query failed: " + e.getMessage());
    }
}
```

### 5.2 前端实现

#### 5.2.1 扩展服务接口

**文件**: `data-agent-frontend/src/services/semanticModel.ts` (修改)

```typescript
import { PageResponse } from './common';

// Add new interface
interface SemanticModelQueryParams {
  agentId: number;
  pageNum: number;
  pageSize: number;
  keyword?: string;
  tableName?: string;
  status?: number;
  createTimeStart?: string;
  createTimeEnd?: string;
}

// Add new method to service class
/**
 * 分页查询语义模型
 * @param params 查询参数
 */
async queryPage(params: SemanticModelQueryParams): Promise<PageResponse<SemanticModel[]>> {
  try {
    const response = await axios.post<PageResponse<SemanticModel[]>>(
      `${API_BASE_URL}/page`,
      params,
    );
    return response.data;
  } catch (error) {
    console.error('Query semantic model page failed:', error);
    throw error;
  }
}

// Export the new interface
export type { SemanticModel, SemanticModelAddDto, SemanticModelQueryParams, /* ... */ };
```

#### 5.2.2 修改组件

**文件**: `data-agent-frontend/src/components/agent/SemanticsConfig.vue` (修改)

**Template部分**:

```vue
<!-- 搜索和筛选区域 -->
<el-form :inline="true" :model="searchForm" style="margin-bottom: 20px">
  <el-form-item label="关键词">
    <el-input
      v-model="searchForm.keyword"
      placeholder="搜索表名/字段名/业务名称"
      clearable
      @clear="handleSearch"
      @keyup.enter="handleSearch"
      style="width: 250px"
    />
  </el-form-item>
  <el-form-item label="状态">
    <el-select
      v-model="searchForm.status"
      placeholder="全部"
      clearable
      style="width: 120px"
    >
      <el-option label="启用" :value="1" />
      <el-option label="停用" :value="0" />
    </el-select>
  </el-form-item>
  <el-form-item>
    <el-button type="primary" @click="handleSearch">搜索</el-button>
    <el-button @click="handleReset">重置</el-button>
  </el-form-item>
</el-form>

<!-- 表格后添加分页 -->
<Pagination
  v-model:page-num="pagination.pageNum"
  v-model:page-size="pagination.pageSize"
  :total="pagination.total"
  :page-sizes="[10, 20, 50, 100]"
  @change="loadSemanticModels"
/>
```

**Script部分**:

```typescript
import Pagination from '@/components/common/Pagination.vue';
import { SemanticModelQueryParams } from '@/services/semanticModel';

// Search form
const searchForm = ref({
  keyword: '',
  status: null as number | null,
});

// Pagination
const pagination = ref({
  pageNum: 1,
  pageSize: 10,
  total: 0,
});

// Modified load function
const loadSemanticModels = async () => {
  try {
    const params: SemanticModelQueryParams = {
      agentId: props.agentId,
      pageNum: pagination.value.pageNum,
      pageSize: pagination.value.pageSize,
      keyword: searchForm.value.keyword || undefined,
      status: searchForm.value.status ?? undefined,
    };

    const response = await semanticModelService.queryPage(params);

    if (response.success) {
      semanticModelList.value = response.data;
      pagination.value.total = response.total;
    } else {
      ElMessage.error(response.message || '加载语义模型列表失败');
    }
  } catch (error) {
    ElMessage.error('加载语义模型列表失败');
    console.error('Failed to load semantic models:', error);
  }
};

const handleSearch = () => {
  pagination.value.pageNum = 1;
  loadSemanticModels();
};

const handleReset = () => {
  searchForm.value = {
    keyword: '',
    status: null,
  };
  handleSearch();
};
```

---

## 6. 智能体列表 (AgentList.vue) 分页实现

### 6.1 后端实现

#### 6.1.1 创建分页查询DTO

**文件**: `data-agent-management/.../dto/agent/AgentQueryDTO.java` (新增)

```java
package com.audaque.cloud.ai.dataagent.dto.agent;

import com.audaque.cloud.ai.dataagent.dto.common.BasePageQueryDTO;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class AgentQueryDTO extends BasePageQueryDTO {
    
    // Fuzzy search by name or description
    private String keyword;
    
    // Filter by status: draft, published, offline
    private String status;
    
    // Filter by category
    private String category;
}
```

#### 6.1.2 扩展Mapper接口

**文件**: `data-agent-management/.../mapper/AgentMapper.java` (修改)

```java
/**
 * Page query agents with filters
 */
@Select("""
    <script>
    SELECT * FROM agent
    WHERE is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR description LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR CAST(id AS CHAR) LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.status != null and queryDTO.status != ''">
        AND status = #{queryDTO.status}
    </if>
    <if test="queryDTO.category != null and queryDTO.category != ''">
        AND category = #{queryDTO.category}
    </if>
    ORDER BY update_time DESC
    ${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, queryDTO.pageSize)}
    </script>
    """)
List<Agent> selectByConditionsWithPage(
    @Param("queryDTO") AgentQueryDTO queryDTO,
    @Param("offset") Integer offset);

/**
 * Count total records by conditions
 */
@Select("""
    <script>
    SELECT COUNT(*) FROM agent
    WHERE is_deleted = 0
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND (name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR description LIKE CONCAT('%', #{queryDTO.keyword}, '%')
             OR CAST(id AS CHAR) LIKE CONCAT('%', #{queryDTO.keyword}, '%'))
    </if>
    <if test="queryDTO.status != null and queryDTO.status != ''">
        AND status = #{queryDTO.status}
    </if>
    <if test="queryDTO.category != null and queryDTO.category != ''">
        AND category = #{queryDTO.category}
    </if>
    </script>
    """)
Long countByConditions(@Param("queryDTO") AgentQueryDTO queryDTO);
```

#### 6.1.3 扩展Service和Controller

**文件**: `data-agent-management/.../service/agent/AgentService.java` (修改)

```java
PageResult<Agent> queryByConditionsWithPage(AgentQueryDTO queryDTO);
```

**文件**: `data-agent-management/.../controller/AgentController.java` (修改)

```java
/**
 * Page query agents with filters
 */
@PostMapping("/page")
public PageResponse<List<Agent>> queryByPage(@Valid @RequestBody AgentQueryDTO queryDTO) {
    try {
        PageResult<Agent> pageResult = agentService.queryByConditionsWithPage(queryDTO);
        return PageResponse.success(pageResult.getData(), pageResult.getTotal(),
                pageResult.getPageNum(), pageResult.getPageSize(), pageResult.getTotalPages());
    } catch (Exception e) {
        log.error("Error querying agent page", e);
        return PageResponse.pageError("Query failed: " + e.getMessage());
    }
}
```

### 6.2 前端实现

#### 6.2.1 扩展服务接口

**文件**: `data-agent-frontend/src/services/agent.ts` (修改)

```typescript
import { PageResponse } from './common';

// Add new interface
export interface AgentQueryParams {
  pageNum: number;
  pageSize: number;
  keyword?: string;
  status?: string;
  category?: string;
}

// Add new method to service class
/**
 * 分页查询智能体列表
 * @param params 查询参数
 */
async queryPage(params: AgentQueryParams): Promise<PageResponse<Agent[]>> {
  try {
    const response = await axios.post<PageResponse<Agent[]>>(
      `${API_BASE_URL}/page`,
      params,
    );
    return response.data;
  } catch (error) {
    console.error('Query agent page failed:', error);
    throw error;
  }
}
```

#### 6.2.2 修改组件

**文件**: `data-agent-frontend/src/views/AgentList.vue` (修改)

**Template部分 - 在 agents-grid 后添加分页**:

```vue
<!-- 智能体网格 -->
<div class="agents-grid" v-if="!loading">
  <!-- existing content -->
</div>

<!-- 分页组件 -->
<div class="pagination-wrapper" v-if="!loading && pagination.total > 0">
  <Pagination
    v-model:page-num="pagination.pageNum"
    v-model:page-size="pagination.pageSize"
    :total="pagination.total"
    :page-sizes="[8, 16, 24, 48]"
    @change="loadAgents"
  />
</div>
```

**Script部分**:

```typescript
import Pagination from '@/components/common/Pagination.vue';
import { AgentQueryParams } from '@/services/agent';

// In setup()
const pagination = ref({
  pageNum: 1,
  pageSize: 16, // 4 per row * 4 rows
  total: 0,
});

// Modified load function
const loadAgents = async () => {
  loading.value = true;
  try {
    const params: AgentQueryParams = {
      pageNum: pagination.value.pageNum,
      pageSize: pagination.value.pageSize,
      keyword: searchKeyword.value || undefined,
      status: activeFilter.value !== 'all' ? activeFilter.value : undefined,
    };

    const response = await agentService.queryPage(params);

    if (response.success) {
      agents.value = response.data || [];
      pagination.value.total = response.total;
    } else {
      ElMessage.error(response.message || '获取智能体列表失败');
      agents.value = [];
    }
  } catch (error) {
    ElMessage.error('获取智能体列表失败，请检查网络！');
    agents.value = [];
  } finally {
    loading.value = false;
  }
};

// Modify filter and search watchers
watch(activeFilter, () => {
  pagination.value.pageNum = 1;
  loadAgents();
});

// Add debounced search
const debouncedSearch = debounce(() => {
  pagination.value.pageNum = 1;
  loadAgents();
}, 300);

watch(searchKeyword, () => {
  debouncedSearch();
});

// Update computed properties to work with paginated data
// Note: Filter by status is now done on server side
const filteredAgents = computed(() => agents.value);
```

**Style部分**:

```css
.pagination-wrapper {
  display: flex;
  justify-content: center;
  padding: 2rem 0;
}
```

---

## 7. 逻辑删除实现规范

### 7.1 逻辑删除字段说明

所有业务表均采用逻辑删除方式，使用 `is_deleted` 字段标识记录是否已删除：

| 字段名       | 类型          | 默认值 | 说明               |
| ------------ | ------------- | ------ | ------------------ |
| `is_deleted` | TINYINT / INT | 0      | 0-未删除，1-已删除 |

### 7.2 后端逻辑删除实现

#### 7.2.1 Entity基类（可选）

**文件**: `data-agent-management/.../entity/BaseEntity.java` (参考)

```java
@Data
public abstract class BaseEntity {
    private Long id;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    
    /**
     * 逻辑删除标识：0-未删除，1-已删除
     */
    private Integer isDeleted = 0;
}
```

#### 7.2.2 Mapper层逻辑删除方法

**通用逻辑删除SQL模式**:

```java
/**
 * 逻辑删除单条记录
 */
@Update("""
    UPDATE table_name 
    SET is_deleted = 1, update_time = NOW() 
    WHERE id = #{id} AND is_deleted = 0
    """)
int logicalDeleteById(@Param("id") Long id);

/**
 * 批量逻辑删除
 */
@Update("""
    <script>
    UPDATE table_name 
    SET is_deleted = 1, update_time = NOW() 
    WHERE is_deleted = 0 AND id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
    </script>
    """)
int logicalDeleteBatch(@Param("ids") List<Long> ids);
```

#### 7.2.3 各业务模块逻辑删除示例

**BusinessKnowledgeMapper.java**:

```java
/**
 * 逻辑删除业务知识
 */
@Update("""
    UPDATE business_knowledge 
    SET is_deleted = 1, updated_time = NOW() 
    WHERE id = #{id} AND is_deleted = 0
    """)
int logicalDeleteById(@Param("id") Long id);

/**
 * 批量逻辑删除业务知识
 */
@Update("""
    <script>
    UPDATE business_knowledge 
    SET is_deleted = 1, updated_time = NOW() 
    WHERE agent_id = #{agentId} AND is_deleted = 0 AND id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
    </script>
    """)
int logicalDeleteBatch(@Param("agentId") Long agentId, @Param("ids") List<Long> ids);
```

**SemanticModelMapper.java**:

```java
/**
 * 逻辑删除语义模型
 */
@Update("""
    UPDATE semantic_model 
    SET is_deleted = 1, updated_time = NOW() 
    WHERE id = #{id} AND is_deleted = 0
    """)
int logicalDeleteById(@Param("id") Long id);

/**
 * 批量逻辑删除语义模型
 */
@Update("""
    <script>
    UPDATE semantic_model 
    SET is_deleted = 1, updated_time = NOW() 
    WHERE agent_id = #{agentId} AND is_deleted = 0 AND id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
    </script>
    """)
int logicalDeleteBatch(@Param("agentId") Long agentId, @Param("ids") List<Long> ids);
```

**DatasourceMapper.java**:

```java
/**
 * 逻辑删除数据源
 */
@Update("""
    UPDATE datasource 
    SET is_deleted = 1, update_time = NOW() 
    WHERE id = #{id} AND is_deleted = 0
    """)
int logicalDeleteById(@Param("id") Long id);
```

**AgentMapper.java**:

```java
/**
 * 逻辑删除智能体
 */
@Update("""
    UPDATE agent 
    SET is_deleted = 1, update_time = NOW() 
    WHERE id = #{id} AND is_deleted = 0
    """)
int logicalDeleteById(@Param("id") Long id);
```

### 7.3 Service层逻辑删除实现

```java
@Override
@Transactional
public boolean delete(Long id) {
    log.info("Logical delete record: id={}", id);
    
    if (id == null) {
        throw new IllegalArgumentException("ID cannot be null");
    }
    
    int affected = mapper.logicalDeleteById(id);
    
    if (affected == 0) {
        log.warn("Record not found or already deleted: id={}", id);
        return false;
    }
    
    log.info("Successfully deleted record: id={}", id);
    return true;
}

@Override
@Transactional
public boolean batchDelete(Long agentId, List<Long> ids) {
    log.info("Batch logical delete: agentId={}, count={}", agentId, ids.size());
    
    if (ids == null || ids.isEmpty()) {
        throw new IllegalArgumentException("IDs cannot be empty");
    }
    
    int affected = mapper.logicalDeleteBatch(agentId, ids);
    
    log.info("Batch delete completed: requested={}, affected={}", ids.size(), affected);
    return affected > 0;
}
```

### 7.4 Controller层批量删除接口

**通用批量删除DTO**:

```java
@Data
public class BatchDeleteDTO {
    
    private Long agentId;
    
    @NotEmpty(message = "IDs cannot be empty")
    private List<Long> ids;
}
```

**Controller示例**:

```java
/**
 * 批量删除记录（逻辑删除）
 */
@DeleteMapping("/batch")
public ApiResponse<Boolean> batchDelete(@Valid @RequestBody BatchDeleteDTO deleteDTO) {
    try {
        log.info("Batch delete request: agentId={}, count={}", 
                deleteDTO.getAgentId(), deleteDTO.getIds().size());

        boolean success = service.batchDelete(deleteDTO.getAgentId(), deleteDTO.getIds());

        if (success) {
            return ApiResponse.success("Batch delete successful", true);
        } else {
            return ApiResponse.error("No records deleted");
        }
    } catch (IllegalArgumentException e) {
        log.error("Invalid batch delete parameters: {}", e.getMessage());
        return ApiResponse.error("Invalid parameters: " + e.getMessage());
    } catch (Exception e) {
        log.error("Error batch deleting records", e);
        return ApiResponse.error("Batch delete failed: " + e.getMessage());
    }
}
```

### 7.5 前端批量删除实现

#### 7.5.1 服务接口

```typescript
/**
 * 批量删除记录
 * @param agentId Agent ID
 * @param ids 记录ID列表
 */
async batchDelete(agentId: number, ids: number[]): Promise<boolean> {
  try {
    const response = await axios.delete<ApiResponse<boolean>>(
      `${API_BASE_URL}/batch`,
      { data: { agentId, ids } },
    );
    return response.data.success;
  } catch (error) {
    console.error('Batch delete failed:', error);
    throw error;
  }
}
```

#### 7.5.2 组件实现

```typescript
// 选中行状态
const selectedRows: Ref<Entity[]> = ref([]);

// 表格选择变化
const handleSelectionChange = (selection: Entity[]) => {
  selectedRows.value = selection;
};

// 批量删除
const handleBatchDelete = async () => {
  if (selectedRows.value.length === 0) {
    ElMessage.warning('请选择要删除的记录');
    return;
  }

  try {
    await ElMessageBox.confirm(
      `确定要删除选中的 ${selectedRows.value.length} 条记录吗？`,
      '确认批量删除',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning',
      },
    );

    const ids = selectedRows.value
      .map(row => row.id)
      .filter(id => id !== undefined) as number[];
      
    const success = await service.batchDelete(props.agentId, ids);

    if (success) {
      ElMessage.success('批量删除成功');
      selectedRows.value = [];
      
      // 处理删除后分页逻辑
      if (dataList.value.length === ids.length && pagination.value.pageNum > 1) {
        pagination.value.pageNum--;
      }
      await loadData();
    } else {
      ElMessage.error('批量删除失败');
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('批量删除失败');
      console.error('Batch delete error:', error);
    }
  }
};
```

### 7.6 查询时过滤已删除记录

**重要**: 所有分页查询和列表查询SQL必须包含 `is_deleted = 0` 条件：

```java
// 分页查询
@Select("""
    <script>
    SELECT * FROM table_name
    WHERE is_deleted = 0  <!-- 必须过滤已删除记录 -->
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
    </if>
    ORDER BY create_time DESC
    ${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, queryDTO.pageSize)}
    </script>
    """)
List<Entity> selectByConditionsWithPage(...);

// 统计查询
@Select("""
    <script>
    SELECT COUNT(*) FROM table_name
    WHERE is_deleted = 0  <!-- 必须过滤已删除记录 -->
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND name LIKE CONCAT('%', #{queryDTO.keyword}, '%')
    </if>
    </script>
    """)
Long countByConditions(...);
```

### 7.7 逻辑删除注意事项

1. **唯一约束处理**: 如果表中有唯一约束字段，逻辑删除后可能导致重复记录无法插入。解决方案：
   - 将唯一约束改为联合唯一约束，包含 `is_deleted` 字段
   - 或在删除时同时修改唯一字段值（如添加时间戳后缀）

2. **关联数据处理**: 删除主记录时，需考虑关联子记录的处理策略：
   - 级联逻辑删除
   - 或保留子记录但标记为孤立状态

3. **数据恢复**: 如需支持数据恢复功能，可添加恢复接口：
   ```java
   @Update("UPDATE table_name SET is_deleted = 0, update_time = NOW() WHERE id = #{id}")
   int restore(@Param("id") Long id);
   ```

4. **定期清理**: 考虑定期物理删除已逻辑删除的历史数据，以节省存储空间。

---

## 8. 错误处理和边界情况

### 8.1 前端错误处理

```typescript
// Common error handler
const handlePageQueryError = (error: any, defaultMessage: string) => {
  if (axios.isAxiosError(error)) {
    if (error.response?.status === 400) {
      ElMessage.error('请求参数错误');
    } else if (error.response?.status === 500) {
      ElMessage.error('服务器内部错误，请稍后重试');
    } else {
      ElMessage.error(error.response?.data?.message || defaultMessage);
    }
  } else {
    ElMessage.error(defaultMessage);
  }
  console.error('Query error:', error);
};
```

### 8.2 边界情况处理

1. **空数据处理**:
   - 当 `total = 0` 时，隐藏分页组件
   - 显示"暂无数据"的空状态提示

2. **删除后自动跳页**:
   ```typescript
   const handleDeleteSuccess = async () => {
     // If current page has no data after delete, go to previous page
     if (dataList.value.length === 1 && pagination.value.pageNum > 1) {
       pagination.value.pageNum--;
     }
     await loadData();
   };
   ```

3. **搜索重置页码**:
   ```typescript
   const handleSearch = () => {
     pagination.value.pageNum = 1; // Always reset to first page
     loadData();
   };
   ```

4. **参数验证**:
   - pageNum 最小值为 1
   - pageSize 范围为 1-100
   - 后端返回验证错误时前端显示友好提示

---

## 9. 性能优化建议

### 9.1 默认页面大小设置

| 组件                    | 建议默认pageSize | 原因                         |
| ----------------------- | ---------------- | ---------------------------- |
| BusinessKnowledgeConfig | 10               | 数据内容较长，适合较小分页   |
| DataSourceConfig        | 10               | 表格带展开行，数据量不宜过多 |
| SemanticsConfig         | 20               | 数据结构简单，可适当增加     |
| AgentList               | 16               | 卡片布局，4x4网格最佳        |

### 9.2 数据库索引优化

```sql
-- 为常用查询字段添加索引
CREATE INDEX idx_bk_agent_keyword ON business_knowledge(agent_id, business_term);
CREATE INDEX idx_sm_agent_table ON semantic_model(agent_id, table_name);
CREATE INDEX idx_agent_status ON agent(status);
CREATE INDEX idx_ds_type ON datasource(type);
```

### 9.3 数据库表结构更新

**注意**: 以下表需要添加 `is_deleted` 字段以支持逻辑删除功能。

> **元数据库 vs 用户数据库**
> - **元数据库**: 存储 DataAgent 系统本身的配置数据（agent、business_knowledge、semantic_model 等表），仅支持 **MySQL** 和 **达梦数据库**
> - **用户数据库**: 用户通过 datasource 配置的外部业务数据库，用于执行 Text-to-SQL 查询，支持 MySQL、PostgreSQL、达梦等多种类型
> 
> 以下迁移脚本仅针对**元数据库**。

#### 9.3.1 现有字段状态检查

| 表名                    | 是否已有 `is_deleted` 字段 | 备注     |
| ----------------------- | -------------------------- | -------- |
| `agent`                 | **否**                     | 需要新增 |
| `business_knowledge`    | 是                         | 无需修改 |
| `semantic_model`        | **否**                     | 需要新增 |
| `datasource`            | **否**                     | 需要新增 |
| `agent_knowledge`       | 是                         | 无需修改 |
| `agent_preset_question` | 是 (`is_delete`)           | 无需修改 |
| `logical_relation`      | 是                         | 无需修改 |
| `model_config`          | 是                         | 无需修改 |

#### 9.3.2 MySQL 更新脚本

```sql
-- ================================================
-- DataAgent 分页功能数据库更新脚本 (MySQL)
-- 版本: 1.0
-- 日期: 2025-02-05
-- ================================================

-- 1. 为 agent 表添加 is_deleted 字段
ALTER TABLE `agent` 
ADD COLUMN `is_deleted` INT DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除' AFTER `human_review_enabled`;

-- 添加索引
CREATE INDEX idx_agent_is_deleted ON agent(is_deleted);

-- 2. 为 semantic_model 表添加 is_deleted 字段
ALTER TABLE `semantic_model` 
ADD COLUMN `is_deleted` INT DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除' AFTER `updated_time`;

-- 添加索引
CREATE INDEX idx_sm_is_deleted ON semantic_model(is_deleted);

-- 3. 为 datasource 表添加 is_deleted 字段
ALTER TABLE `datasource` 
ADD COLUMN `is_deleted` INT DEFAULT 0 COMMENT '逻辑删除：0-未删除，1-已删除' AFTER `update_time`;

-- 添加索引
CREATE INDEX idx_ds_is_deleted ON datasource(is_deleted);

-- 4. 优化复合索引（可选，提升分页查询性能）
-- 业务知识表：agent_id + is_deleted + created_time
CREATE INDEX idx_bk_agent_deleted_time ON business_knowledge(agent_id, is_deleted, created_time);

-- 语义模型表：agent_id + is_deleted + created_time
CREATE INDEX idx_sm_agent_deleted_time ON semantic_model(agent_id, is_deleted, created_time);

-- 智能体表：is_deleted + update_time
CREATE INDEX idx_agent_deleted_update ON agent(is_deleted, update_time);
```

#### 9.3.3 达梦数据库 (DM) 更新脚本

```sql
-- ================================================
-- DataAgent 分页功能数据库更新脚本 (达梦)
-- 版本: 1.0
-- 日期: 2025-02-05
-- ================================================

-- 1. 为 agent 表添加 is_deleted 字段
ALTER TABLE "agent" ADD "is_deleted" INT DEFAULT 0;
COMMENT ON COLUMN "agent"."is_deleted" IS '逻辑删除：0-未删除，1-已删除';

-- 添加索引
CREATE INDEX "idx_agent_is_deleted" ON "agent"("is_deleted");

-- 2. 为 semantic_model 表添加 is_deleted 字段
ALTER TABLE "semantic_model" ADD "is_deleted" INT DEFAULT 0;
COMMENT ON COLUMN "semantic_model"."is_deleted" IS '逻辑删除：0-未删除，1-已删除';

-- 添加索引
CREATE INDEX "idx_sm_is_deleted" ON "semantic_model"("is_deleted");

-- 3. 为 datasource 表添加 is_deleted 字段
ALTER TABLE "datasource" ADD "is_deleted" INT DEFAULT 0;
COMMENT ON COLUMN "datasource"."is_deleted" IS '逻辑删除：0-未删除，1-已删除';

-- 添加索引
CREATE INDEX "idx_ds_is_deleted" ON "datasource"("is_deleted");

-- 4. 优化复合索引（可选）
CREATE INDEX "idx_bk_agent_deleted_time" ON "business_knowledge"("agent_id", "is_deleted", "created_time");
CREATE INDEX "idx_sm_agent_deleted_time" ON "semantic_model"("agent_id", "is_deleted", "created_time");
CREATE INDEX "idx_agent_deleted_update" ON "agent"("is_deleted", "update_time");
```

#### 9.3.4 迁移脚本文件

**文件位置**: `data-agent-management/src/main/resources/sql/migration/`

**命名规范**: `V{版本号}_{描述}.sql` 和 `V{版本号}_{描述}_dameng.sql`

##### V2_add_is_deleted_for_pagination.sql (MySQL)

```sql
-- Migration script: Add is_deleted column to support pagination with logical delete
-- Date: 2025-02-05
-- Database: MySQL (元数据库)
-- Affects: agent, semantic_model, datasource tables

-- ================================================
-- 1. agent table
-- ================================================
ALTER TABLE agent 
ADD COLUMN is_deleted INT DEFAULT 0;

COMMENT ON COLUMN agent.is_deleted IS '逻辑删除：0-未删除，1-已删除';

CREATE INDEX idx_agent_is_deleted ON agent(is_deleted);

UPDATE agent SET is_deleted = 0 WHERE is_deleted IS NULL;

-- ================================================
-- 2. semantic_model table
-- ================================================
ALTER TABLE semantic_model 
ADD COLUMN is_deleted INT DEFAULT 0;

COMMENT ON COLUMN semantic_model.is_deleted IS '逻辑删除：0-未删除，1-已删除';

CREATE INDEX idx_sm_is_deleted ON semantic_model(is_deleted);

UPDATE semantic_model SET is_deleted = 0 WHERE is_deleted IS NULL;

-- ================================================
-- 3. datasource table
-- ================================================
ALTER TABLE datasource 
ADD COLUMN is_deleted INT DEFAULT 0;

COMMENT ON COLUMN datasource.is_deleted IS '逻辑删除：0-未删除，1-已删除';

CREATE INDEX idx_ds_is_deleted ON datasource(is_deleted);

UPDATE datasource SET is_deleted = 0 WHERE is_deleted IS NULL;

-- ================================================
-- 4. Composite indexes for pagination performance (optional)
-- ================================================
CREATE INDEX idx_bk_agent_deleted_time ON business_knowledge(agent_id, is_deleted, created_time);
CREATE INDEX idx_sm_agent_deleted_time ON semantic_model(agent_id, is_deleted, created_time);
CREATE INDEX idx_agent_deleted_update ON agent(is_deleted, update_time);
```

##### V2_add_is_deleted_for_pagination_dameng.sql (达梦数据库)

```sql
-- Migration script: Add is_deleted column to support pagination with logical delete
-- Date: 2025-02-05
-- Database: DaMeng (达梦数据库)
-- Affects: agent, semantic_model, datasource tables

-- ================================================
-- 1. agent table
-- ================================================
ALTER TABLE "agent" ADD "is_deleted" INT DEFAULT 0;

COMMENT ON COLUMN "agent"."is_deleted" IS '逻辑删除：0-未删除，1-已删除';

CREATE INDEX "idx_agent_is_deleted" ON "agent"("is_deleted");

UPDATE "agent" SET "is_deleted" = 0 WHERE "is_deleted" IS NULL;

-- ================================================
-- 2. semantic_model table
-- ================================================
ALTER TABLE "semantic_model" ADD "is_deleted" INT DEFAULT 0;

COMMENT ON COLUMN "semantic_model"."is_deleted" IS '逻辑删除：0-未删除，1-已删除';

CREATE INDEX "idx_sm_is_deleted" ON "semantic_model"("is_deleted");

UPDATE "semantic_model" SET "is_deleted" = 0 WHERE "is_deleted" IS NULL;

-- ================================================
-- 3. datasource table
-- ================================================
ALTER TABLE "datasource" ADD "is_deleted" INT DEFAULT 0;

COMMENT ON COLUMN "datasource"."is_deleted" IS '逻辑删除：0-未删除，1-已删除';

CREATE INDEX "idx_ds_is_deleted" ON "datasource"("is_deleted");

UPDATE "datasource" SET "is_deleted" = 0 WHERE "is_deleted" IS NULL;

-- ================================================
-- 4. Composite indexes for pagination performance (optional)
-- ================================================
CREATE INDEX "idx_bk_agent_deleted_time" ON "business_knowledge"("agent_id", "is_deleted", "created_time");
CREATE INDEX "idx_sm_agent_deleted_time" ON "semantic_model"("agent_id", "is_deleted", "created_time");
CREATE INDEX "idx_agent_deleted_update" ON "agent"("is_deleted", "update_time");

-- Commit changes
COMMIT;
```

#### 9.3.5 执行顺序说明

1. **备份数据**: 执行前请先备份相关表的数据
2. **执行顺序**: 按照脚本中的序号顺序执行
3. **验证**: 执行后验证字段是否正确添加
4. **回滚脚本**: 如需回滚，可使用以下语句

```sql
-- MySQL 回滚
ALTER TABLE agent DROP COLUMN is_deleted;
ALTER TABLE semantic_model DROP COLUMN is_deleted;
ALTER TABLE datasource DROP COLUMN is_deleted;

-- 达梦 回滚
ALTER TABLE "agent" DROP COLUMN "is_deleted";
ALTER TABLE "semantic_model" DROP COLUMN "is_deleted";
ALTER TABLE "datasource" DROP COLUMN "is_deleted";
```

### 9.4 前端防抖优化

```typescript
import { debounce } from 'lodash-es';

// Debounce search input
const debouncedSearch = debounce(() => {
  handleSearch();
}, 300);
```

---

## 10. 单元测试要点

### 10.1 后端测试

```java
@Test
void testQueryByConditionsWithPage_Success() {
    // Given
    QueryDTO queryDTO = new QueryDTO();
    queryDTO.setAgentId(1L);
    queryDTO.setPageNum(1);
    queryDTO.setPageSize(10);
    
    // When
    PageResult<Entity> result = service.queryByConditionsWithPage(queryDTO);
    
    // Then
    assertNotNull(result);
    assertEquals(1, result.getPageNum());
    assertEquals(10, result.getPageSize());
    assertTrue(result.getTotal() >= 0);
}

@Test
void testQueryByConditionsWithPage_InvalidParams() {
    // Given
    QueryDTO queryDTO = new QueryDTO();
    queryDTO.setPageNum(0); // Invalid
    
    // Then
    assertThrows(ConstraintViolationException.class, () -> {
        service.queryByConditionsWithPage(queryDTO);
    });
}
```

### 10.2 前端测试

```typescript
describe('Pagination Component', () => {
  it('should emit change event when page changes', async () => {
    const wrapper = mount(Pagination, {
      props: { total: 100, pageNum: 1, pageSize: 10 }
    });
    
    await wrapper.find('.el-pager li:nth-child(2)').trigger('click');
    
    expect(wrapper.emitted('change')).toBeTruthy();
    expect(wrapper.emitted('update:pageNum')?.[0]).toEqual([2]);
  });
});
```

---

## 11. 实施清单

### 11.1 文件修改清单

| 文件路径                                       | 修改类型 | 说明                               |
| ---------------------------------------------- | -------- | ---------------------------------- |
| `services/common.ts`                           | 修改     | 添加通用分页接口定义               |
| `services/businessKnowledge.ts`                | 修改     | 添加queryPage方法和QueryParams接口 |
| `services/semanticModel.ts`                    | 修改     | 添加queryPage方法和QueryParams接口 |
| `services/datasource.ts`                       | 修改     | 添加queryPage方法和QueryParams接口 |
| `services/agent.ts`                            | 修改     | 添加queryPage方法和QueryParams接口 |
| `components/agent/BusinessKnowledgeConfig.vue` | 修改     | 添加分页功能                       |
| `components/agent/DataSourceConfig.vue`        | 修改     | 添加分页功能                       |
| `components/agent/SemanticsConfig.vue`         | 修改     | 添加分页功能                       |
| `views/AgentList.vue`                          | 修改     | 添加分页功能                       |
| `composables/usePagination.ts`                 | 新增     | 通用分页Hook (可选)                |

### 11.2 后端文件修改清单

| 文件路径                                       | 修改类型 | 说明             |
| ---------------------------------------------- | -------- | ---------------- |
| `dto/common/BasePageQueryDTO.java`             | 新增     | 通用分页查询基类 |
| `dto/knowledge/BusinessKnowledgeQueryDTO.java` | 新增     | 业务知识查询DTO  |
| `dto/semantic/SemanticModelQueryDTO.java`      | 新增     | 语义模型查询DTO  |
| `dto/datasource/DatasourceQueryDTO.java`       | 新增     | 数据源查询DTO    |
| `dto/agent/AgentQueryDTO.java`                 | 新增     | 智能体查询DTO    |
| `mapper/BusinessKnowledgeMapper.java`          | 修改     | 添加分页查询方法 |
| `mapper/SemanticModelMapper.java`              | 修改     | 添加分页查询方法 |
| `mapper/DatasourceMapper.java`                 | 修改     | 添加分页查询方法 |
| `mapper/AgentMapper.java`                      | 修改     | 添加分页查询方法 |
| `service/*/Service.java`                       | 修改     | 添加分页查询接口 |
| `service/*/ServiceImpl.java`                   | 修改     | 添加分页查询实现 |
| `controller/*Controller.java`                  | 修改     | 添加分页查询端点 |

---

## 12. API接口汇总

| 接口路径                        | 方法   | 说明             |
| ------------------------------- | ------ | ---------------- |
| `/api/business-knowledge/page`  | POST   | 分页查询业务知识 |
| `/api/business-knowledge/batch` | DELETE | 批量删除业务知识 |
| `/api/semantic-model/page`      | POST   | 分页查询语义模型 |
| `/api/semantic-model/batch`     | DELETE | 批量删除语义模型 |
| `/api/datasource/page`          | POST   | 分页查询数据源   |
| `/api/agent/page`               | POST   | 分页查询智能体   |

---

**文档版本**: v1.0  
**创建日期**: 2025-02-05  
**作者**: DataAgent Team
