# TODO 需求列表

## 概述

本文档记录了 `c:/data/code/DataAgent/data-agent-management/src/main/java` 目录下所有待处理的TODO项。

---

## TODO 详细列表

### 1. McpServerConfig.java

- **文件路径**: `c:/data/code/DataAgent/data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/config/McpServerConfig.java`
- **行号**: 25
- **TODO完整内容**: `// TODO 2025/12/08 合并包后移动到DataAgentConfiguration  中`
- **所在类名**: `McpServerConfig` (类级别注释)
- **优先级**: 中等（有时间标记）
- **类型**: 配置重构

**说明**: 需要在2025年12月8日之前，将McpServerConfig配置类合并到DataAgentConfiguration中。

---

#### 实现逻辑

**目标**: 将 `McpServerConfig` 类中的配置逻辑合并到 `DataAgentConfiguration` 类中，简化配置结构。

**实现步骤**:

1. **分析现有配置**
   - `McpServerConfig` 当前包含一个 `@Bean` 方法 `mcpServerTools`，用于创建 `ToolCallbackProvider`
   - 该方法使用 `@McpServerTool` 注解来解决循环依赖问题
   - `DataAgentConfiguration` 已经存在，包含多个配置方法

2. **迁移配置方法**
   - 将 `mcpServerTools` 方法从 `McpServerConfig` 移动到 `DataAgentConfiguration`
   - 保持原有的 `@McpServerTool` 注解和逻辑不变
   - 确保依赖注入正确（`McpServerService` 仍然需要注入）

3. **更新导入语句**
   - 在 `DataAgentConfiguration` 中添加必要的导入：
     - `com.audaque.cloud.ai.dataagent.annotation.McpServerTool`
     - `com.audaque.cloud.ai.dataagent.service.mcp.McpServerService`
     - `org.springframework.ai.tool.ToolCallbackProvider`
     - `org.springframework.ai.tool.method.MethodToolCallbackProvider`

4. **删除旧配置类**
   - 删除 `McpServerConfig.java` 文件
   - 从 `@Configuration` 扫描路径中移除（如果有明确配置）

5. **验证配置**
   - 确保应用启动时 `mcpServerTools` Bean 正确创建
   - 验证循环依赖问题得到解决
   - 运行相关测试用例确保功能正常

**代码示例**:

```java
// DataAgentConfiguration.java 中添加以下方法

/**
 * MCP Server工具回调提供者配置
 * 解决ChatClient和MCP工具的循环依赖问题
 */
@Bean
@McpServerTool
public ToolCallbackProvider mcpServerTools(McpServerService mcpServerService) {
    return MethodToolCallbackProvider.builder().toolObjects(mcpServerService).build();
}
```

**注意事项**:
- 保持 `@McpServerTool` 注解的使用，这是解决循环依赖的关键
- 确保迁移后不影响现有的MCP Server功能
- 如果有其他地方引用 `McpServerConfig`，需要更新引用

---

### 2. PlanExecutorNode.java

- **文件路径**: `c:/data/code/DataAgent/data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/workflow/node/PlanExecutorNode.java`
- **行号**: 50
- **TODO完整内容**: `// TODO 待优化，校验应该在生成计划之后而不是这里，这里导致每次运行一个计划都校验一次`
- **所在类名**: `PlanExecutorNode`
- **所在方法名**: `apply(OverAllState state)`
- **优先级**: 高（性能优化相关）
- **类型**: 性能优化

**说明**: 当前计划校验逻辑在每次执行计划时都会运行，应该将校验逻辑移到计划生成之后，避免重复校验，提升性能。

---

#### 实现逻辑

**目标**: 将计划校验逻辑从每次执行时移到计划生成后执行，避免重复校验，提升性能。

**问题分析**:
- 当前 `PlanExecutorNode.apply()` 方法中每次执行计划都会进行完整的校验
- 校验包括：计划结构校验、执行步骤校验、工具参数校验等
- 这导致即使计划已经校验过，每次执行步骤时都会重复校验
- 性能浪费，特别是在多步骤执行场景中

**实现步骤**:

1. **创建校验工具类**
   - 新建 `PlanValidator` 工具类，专门负责计划校验
   - 将 `PlanExecutorNode` 中的校验方法抽取到该工具类
   - 提供静态方法 `validatePlan(Plan plan)` 返回校验结果

2. **修改 PlannerNode**
   - 在 `PlannerNode` 中生成计划后立即调用校验
   - 将校验结果存储到 `OverAllState` 中
   - 如果校验失败，直接返回错误信息，不进入执行流程

3. **修改 PlanExecutorNode**
   - 从 `apply()` 方法中移除校验逻辑
   - 从 `OverAllState` 中读取校验结果
   - 如果校验未通过，直接跳转到修复流程
   - 只保留执行步骤的流转逻辑

4. **状态管理**
   - 在常量类中添加新状态键：
     - `PLAN_VALIDATED`: 标记计划是否已校验
     - `PLAN_VALIDATION_RESULT`: 存储校验结果

**代码示例**:

```java
// PlanValidator.java (新建)
public class PlanValidator {
    
    public static ValidationResult validatePlan(Plan plan) {
        // 1. 校验计划结构
        if (plan == null || plan.getExecutionPlan() == null || plan.getExecutionPlan().isEmpty()) {
            return ValidationResult.failure("计划结构为空");
        }
        
        // 2. 校验每个执行步骤
        for (ExecutionStep step : plan.getExecutionPlan()) {
            ValidationResult stepResult = validateExecutionStep(step);
            if (!stepResult.isValid()) {
                return stepResult;
            }
        }
        
        return ValidationResult.success();
    }
    
    private static ValidationResult validateExecutionStep(ExecutionStep step) {
        // 校验工具名称
        if (step.getToolToUse() == null || !SUPPORTED_NODES.contains(step.getToolToUse())) {
            return ValidationResult.failure("无效的工具名称: " + step.getToolToUse());
        }
        
        // 校验工具参数
        if (step.getToolParameters() == null) {
            return ValidationResult.failure("工具参数缺失");
        }
        
        // 根据节点类型校验特定参数
        switch (step.getToolToUse()) {
            case SQL_GENERATE_NODE:
                if (!StringUtils.hasText(step.getToolParameters().getInstruction())) {
                    return ValidationResult.failure("SQL生成节点缺少描述");
                }
                break;
            // ... 其他节点类型校验
        }
        
        return ValidationResult.success();
    }
}

// PlannerNode.java (修改)
public Map<String, Object> apply(OverAllState state) throws Exception {
    // ... 生成计划的代码 ...
    
    Plan plan = PlanProcessUtil.getPlan(state);
    
    // 生成后立即校验
    ValidationResult validationResult = PlanValidator.validatePlan(plan);
    
    if (!validationResult.isValid()) {
        log.error("Plan validation failed: {}", validationResult.getErrorMessage());
        return Map.of(
            PLAN_VALIDATED, false,
            PLAN_VALIDATION_ERROR, validationResult.getErrorMessage(),
            PLAN_REPAIR_COUNT, 1
        );
    }
    
    log.info("Plan validation successful");
    return Map.of(PLAN_VALIDATED, true, PLANNER_NODE_OUTPUT, generator);
}

// PlanExecutorNode.java (修改)
public Map<String, Object> apply(OverAllState state) throws Exception {
    // 检查计划是否已校验
    Boolean validated = state.value(PLAN_VALIDATED, false);
    if (!validated) {
        // 如果没有校验标记，说明是旧流程，需要兼容处理
        // 可以选择在这里进行校验，或者直接返回错误
        log.warn("Plan not validated, skipping execution");
        return Map.of(PLAN_VALIDATION_STATUS, false, 
                     PLAN_VALIDATION_ERROR, "计划未校验");
    }
    
    // 检查是否有校验错误
    String validationError = state.value(PLAN_VALIDATION_ERROR, null);
    if (validationError != null) {
        return Map.of(PLAN_VALIDATION_STATUS, false, 
                     PLAN_VALIDATION_ERROR, validationError);
    }
    
    // 直接执行计划，无需再次校验
    Plan plan = PlanProcessUtil.getPlan(state);
    int currentStep = PlanProcessUtil.getCurrentStepNumber(state);
    List<ExecutionStep> executionPlan = plan.getExecutionPlan();
    
    // ... 执行步骤的逻辑 ...
}
```

**注意事项**:
- 保持向后兼容性，处理旧流程中未校验的情况
- 校验失败时，确保能正确触发修复流程
- 添加详细的日志记录，便于调试
- 考虑添加单元测试验证校验逻辑的正确性

---

### 3. BusinessKnowledgeService.java

- **文件路径**: `c:/data/code/DataAgent/data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/service/business/BusinessKnowledgeService.java`
- **行号**: 24
- **TODO完整内容**: `// TODO 添加一个分页查询的方法`
- **所在类名**: `BusinessKnowledgeService` (接口级别注释)
- **优先级**: 中等（功能增强）
- **类型**: 功能增强

**说明**: 需要在BusinessKnowledgeService接口中添加分页查询方法，以支持大数据量的业务知识查询。

---

#### 实现逻辑

**目标**: 为 `BusinessKnowledgeService` 添加分页查询功能，支持大数据量的业务知识查询。

**实现步骤**:

1. **创建分页DTO类**
   - 新建 `PageQueryDTO` 通用分页查询参数类
   - 新建 `PageResultDTO<T>` 通用分页结果类

2. **创建业务知识分页查询DTO**
   - 新建 `BusinessKnowledgePageQueryDTO` 继承 `PageQueryDTO`
   - 包含查询条件：agentId、keyword、businessTerm等

3. **修改 Mapper 接口**
   - 在 `BusinessKnowledgeMapper` 中添加分页查询方法
   - 使用 MyBatis-Plus 的 `Page<T>` 和 `IPage<T>` 进行分页

4. **修改 Service 接口**
   - 在 `BusinessKnowledgeService` 中添加分页查询方法签名

5. **修改 Service 实现**
   - 在 `BusinessKnowledgeServiceImpl` 中实现分页查询方法
   - 调用 Mapper 的分页查询方法
   - 转换为 VO 对象返回

**代码示例**:

```java
// PageQueryDTO.java (新建)
@Data
public class PageQueryDTO {
    @Min(value = 1, message = "页码必须大于0")
    private Integer pageNum = 1;

    @Min(value = 1, message = "每页数量必须大于0")
    @Max(value = 100, message = "每页数量不能超过100")
    private Integer pageSize = 10;

    public <T> Page<T> toPage() {
        return new Page<>(pageNum, pageSize);
    }
}

// PageResultDTO.java (新建)
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResultDTO<T> {
    private List<T> records;
    private Long total;
    private Integer pageNum;
    private Integer pageSize;
    private Integer pages;

    public static <T> PageResultDTO<T> of(IPage<T> page) {
        return new PageResultDTO<>(
            page.getRecords(),
            page.getTotal(),
            (int) page.getCurrent(),
            (int) page.getSize(),
            (int) page.getPages()
        );
    }
}

// BusinessKnowledgePageQueryDTO.java (新建)
@Data
@EqualsAndHashCode(callSuper = true)
public class BusinessKnowledgePageQueryDTO extends PageQueryDTO {
    private Long agentId;
    private String keyword;
    private String businessTerm;
}

// BusinessKnowledgeService.java (修改)
public interface BusinessKnowledgeService {
    // ... 现有方法 ...

    /**
     * 分页查询业务知识
     * @param queryDTO 分页查询参数
     * @return 分页结果
     */
    PageResultDTO<BusinessKnowledgeVO> pageKnowledge(BusinessKnowledgePageQueryDTO queryDTO);
}

// BusinessKnowledgeMapper.java (修改)
public interface BusinessKnowledgeMapper extends BaseMapper<BusinessKnowledge> {

    /**
     * 分页查询业务知识
     * @param page 分页参数
     * @param queryDTO 查询条件
     * @return 分页结果
     */
    IPage<BusinessKnowledge> selectPageByQuery(Page<BusinessKnowledge> page, 
                                               @Param("query") BusinessKnowledgePageQueryDTO queryDTO);

    // ... 现有方法 ...
}

// BusinessKnowledgeMapper.xml (新增SQL)
<select id="selectPageByQuery" resultType="com.audaque.cloud.ai.dataagent.entity.BusinessKnowledge">
    SELECT * FROM business_knowledge
    WHERE is_deleted = 0
    <if test="query.agentId != null">
        AND agent_id = #{query.agentId}
    </if>
    <if test="query.keyword != null and query.keyword != ''">
        AND (
            business_term LIKE CONCAT('%', #{query.keyword}, '%')
            OR description LIKE CONCAT('%', #{query.keyword}, '%')
            OR synonyms LIKE CONCAT('%', #{query.keyword}, '%')
        )
    </if>
    <if test="query.businessTerm != null and query.businessTerm != ''">
        AND business_term LIKE CONCAT('%', #{query.businessTerm}, '%')
    </if>
    ORDER BY created_time DESC
</select>

// BusinessKnowledgeServiceImpl.java (修改)
@Service
@AllArgsConstructor
public class BusinessKnowledgeServiceImpl implements BusinessKnowledgeService {

    // ... 现有代码 ...

    @Override
    public PageResultDTO<BusinessKnowledgeVO> pageKnowledge(BusinessKnowledgePageQueryDTO queryDTO) {
        IPage<BusinessKnowledge> page = businessKnowledgeMapper.selectPageByQuery(
            queryDTO.toPage(), 
            queryDTO
        );
        
        List<BusinessKnowledgeVO> voList = page.getRecords().stream()
            .map(businessKnowledgeConverter::toVo)
            .toList();
        
        return PageResultDTO.of(new Page<>(voList, page.getTotal(), 
            (int) page.getCurrent(), (int) page.getSize()));
    }
}
```

**注意事项**:
- 分页参数需要校验，防止SQL注入
- 考虑添加缓存机制提升查询性能
- 默认按创建时间倒序排列
- 支持多条件组合查询

---

### 4. OssFileStorageServiceImpl.java

- **文件路径**: `c:/data/code/DataAgent/data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/service/file/impls/OssFileStorageServiceImpl.java`
- **行号**: 144
- **TODO完整内容**: `// TODO 实现`
- **所在类名**: `OssFileStorageServiceImpl`
- **所在方法名**: `getFileResource(String filePath)`
- **优先级**: 高（功能未实现）
- **类型**: 功能实现

**说明**: `getFileResource` 方法目前未实现，需要补充实现从OSS获取文件资源的逻辑。

---

#### 实现逻辑

**目标**: 实现 `getFileResource` 方法，从阿里云OSS获取文件资源，返回 `Resource` 对象供 `TikaDocumentReader` 使用。

**实现步骤**:

1. **分析需求**
   - `AgentKnowledgeResourceManager.getAndSplitDocument()` 方法需要调用 `fileStorageService.getFileResource(filePath)`
   - 返回的 `Resource` 对象会被 `TikaDocumentReader` 用于读取文件内容
   - 需要支持 `Resource` 接口的所有必要方法

2. **创建自定义 Resource 实现**
   - 新建 `OssResource` 类实现 `Resource` 接口
   - 封装 OSS 客户端和对象键
   - 实现必要的 `Resource` 接口方法

3. **实现 getFileResource 方法**
   - 参数校验：检查 filePath 是否为空
   - 检查文件是否存在：使用 `ossClient.doesObjectExist()`
   - 创建并返回 `OssResource` 对象
   - 添加异常处理和日志记录

**代码示例**:

```java
// OssResource.java (新建)
import org.springframework.core.io.AbstractResource;
import org.springframework.core.io.InputStreamSource;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.URL;

/**
 * 阿里云OSS资源实现
 */
public class OssResource extends AbstractResource {

    private final OSS ossClient;
    private final String bucketName;
    private final String objectKey;
    private final String description;

    public OssResource(OSS ossClient, String bucketName, String objectKey) {
        this.ossClient = ossClient;
        this.bucketName = bucketName;
        this.objectKey = objectKey;
        this.description = "OSS resource [bucket='" + bucketName + "', key='" + objectKey + "']";
    }

    @Override
    public String getDescription() {
        return this.description;
    }

    @Override
    public InputStream getInputStream() throws IOException {
        try {
            OSSObject ossObject = ossClient.getObject(bucketName, objectKey);
            return ossObject.getObjectContent();
        } catch (OSSException e) {
            throw new IOException("Failed to get OSS object: " + e.getErrorMessage(), e);
        } catch (ClientException e) {
            throw new IOException("Failed to get OSS object: " + e.getErrorMessage(), e);
        }
    }

    @Override
    public boolean exists() {
        return ossClient.doesObjectExist(bucketName, objectKey);
    }

    @Override
    public boolean isReadable() {
        return exists();
    }

    @Override
    public boolean isOpen() {
        return false;
    }

    @Override
    public URL getURL() throws IOException {
        // 如果配置了自定义域名，返回自定义域名URL
        String customDomain = ossProperties.getCustomDomain();
        if (StringUtils.hasText(customDomain)) {
            return new URL(customDomain + "/" + objectKey);
        }
        // 否则返回OSS默认URL
        String url = ossClient.getPresignedHttpRequest(bucketName, objectKey, 7 * 24 * 3600).getURL().toString();
        return new URL(url);
    }

    @Override
    public URI getURI() throws IOException {
        return getURL().toURI();
    }

    @Override
    public File getFile() throws IOException {
        throw new FileNotFoundException("OSS resource cannot be resolved to absolute file path");
    }

    @Override
    public long contentLength() throws IOException {
        try {
            OSSObject ossObject = ossClient.getObject(bucketName, objectKey);
            long length = ossObject.getObjectMetadata().getContentLength();
            ossObject.getObjectContent().close();
            return length;
        } catch (OSSException e) {
            throw new IOException("Failed to get OSS object content length: " + e.getErrorMessage(), e);
        } catch (ClientException e) {
            throw new IOException("Failed to get OSS object content length: " + e.getErrorMessage(), e);
        }
    }

    @Override
    public long lastModified() throws IOException {
        try {
            OSSObject ossObject = ossClient.getObject(bucketName, objectKey);
            long lastModified = ossObject.getObjectMetadata().getLastModified().getTime();
            ossObject.getObjectContent().close();
            return lastModified;
        } catch (OSSException e) {
            throw new IOException("Failed to get OSS object last modified: " + e.getErrorMessage(), e);
        } catch (ClientException e) {
            throw new IOException("Failed to get OSS object last modified: " + e.getErrorMessage(), e);
        }
    }

    @Override
    public Resource createRelative(String relativePath) throws IOException {
        throw new UnsupportedOperationException("OSS resource does not support createRelative");
    }

    @Override
    public String getFilename() {
        int lastSlashIndex = objectKey.lastIndexOf('/');
        return lastSlashIndex >= 0 ? objectKey.substring(lastSlashIndex + 1) : objectKey;
    }
}

// OssFileStorageServiceImpl.java (修改)
@Override
public Resource getFileResource(String filePath) {
    if (!StringUtils.hasText(filePath)) {
        log.warn("File path is empty, cannot get resource from OSS");
        return null;
    }

    try {
        // 检查文件是否存在
        if (!ossClient.doesObjectExist(ossProperties.getBucketName(), filePath)) {
            log.warn("File not found in OSS: {}", filePath);
            return null;
        }

        // 创建并返回 OSS Resource
        OssResource resource = new OssResource(ossClient, ossProperties.getBucketName(), filePath);
        log.info("Successfully created OSS resource for file: {}", filePath);
        return resource;

    } catch (Exception e) {
        log.error("Failed to get resource from OSS: {}", filePath, e);
        return null;
    }
}
```

**注意事项**:
- 需要添加必要的导入：`com.aliyun.oss.OSS`、`com.aliyun.oss.OSSException`、`com.aliyun.oss.ClientException`、`com.aliyun.oss.model.OSSObject`
- `OssResource` 类需要放在与 `OssFileStorageServiceImpl` 相同的包中，或者单独的 `resource` 包中
- `getFile()` 方法抛出 `FileNotFoundException`，因为 OSS 资源不能解析为绝对文件路径
- `contentLength()` 和 `lastModified()` 方法会获取对象后关闭流，避免资源泄漏
- 考虑添加缓存机制，避免频繁调用 OSS API
- 确保 `OssResource` 的 `getInputStream()` 返回的流在使用后正确关闭

---

### 5. TextSplitterFactory.java

- **文件路径**: `c:/data/code/DataAgent/data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/service/knowledge/TextSplitterFactory.java`
- **行号**: 26
- **TODO完整内容**: `// TODO 后续需改造 AgentKnowledgeResourceManager 使用该类获取对应的 TextSplitter，然后前端提供页面让用户选择不同的切割方式`
- **所在类名**: `TextSplitterFactory` (类级别注释)
- **优先级**: 中等（功能增强）
- **类型**: 功能增强

**说明**: 需要改造AgentKnowledgeResourceManager，使其使用TextSplitterFactory获取对应的TextSplitter，并在前端提供页面让用户选择不同的文本切割方式。

---

#### 实现逻辑

**目标**: 改造 `AgentKnowledgeResourceManager` 使用 `TextSplitterFactory` 获取对应的 `TextSplitter`，支持用户在前端选择不同的文本切割方式。

**问题分析**:
- 当前 `AgentKnowledgeResourceManager` 直接注入固定的 `TextSplitter`
- 无法支持用户选择不同的切割方式
- `TextSplitterFactory` 已经存在，可以根据类型获取不同的 `TextSplitter`
- 需要将切割方式的选择存储在 `AgentKnowledge` 实体中

**实现步骤**:

1. **修改实体类**
   - 在 `AgentKnowledge` 实体中添加 `splitterType` 字段
   - 字段类型为 `String`，存储切割方式类型（如 "token", "recursive"）
   - 添加默认值为 "token"

2. **修改数据库表**
   - 在 `agent_knowledge` 表中添加 `splitter_type` 字段
   - 字段类型为 `VARCHAR(50)`，默认值为 'token'
   - 添加索引以提升查询性能

3. **修改 DTO 类**
   - 在 `CreateAgentKnowledgeDTO` 中添加 `splitterType` 字段
   - 在 `UpdateAgentKnowledgeDTO` 中添加 `splitterType` 字段
   - 在 `AgentKnowledgeVO` 中添加 `splitterType` 字段

4. **修改 AgentKnowledgeResourceManager**
   - 将注入的 `TextSplitter` 改为注入 `TextSplitterFactory`
   - 在 `getAndSplitDocument` 方法中，根据 `AgentKnowledge.splitterType` 获取对应的 `TextSplitter`
   - 处理切割方式为空的情况，使用默认的 "token" 切割方式

5. **修改 Mapper**
   - 更新 `insert` 和 `update` SQL，包含 `splitter_type` 字段

6. **前端页面**
   - 在知识管理页面添加切割方式选择器
   - 提供选项：Token 切割、递归切割等
   - 保存时将选择的切割方式存储到 `splitterType` 字段

**代码示例**:

```java
// AgentKnowledge.java (修改)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AgentKnowledge {
    // ... 现有字段 ...

    // 文本切割方式：token, recursive
    private String splitterType;

    // ... 现有字段 ...
}

// CreateAgentKnowledgeDTO.java (修改)
@Data
public class CreateAgentKnowledgeDTO {
    // ... 现有字段 ...

    /**
     * 文本切割方式：token, recursive
     * 默认值：token
     */
    private String splitterType = "token";

    // ... 现有字段 ...
}

// AgentKnowledgeResourceManager.java (修改)
@Slf4j
@Component
@RequiredArgsConstructor
public class AgentKnowledgeResourceManager {

    private final TextSplitterFactory textSplitterFactory;

    private final FileStorageService fileStorageService;

    private final AgentVectorStoreService agentVectorStoreService;

    // ... 现有代码 ...

    private List<Document> getAndSplitDocument(AgentKnowledge knowledge) {
        // 使用FileStorageService获取文件资源对象
        Resource resource = fileStorageService.getFileResource(knowledge.getFilePath());

        // 使用TikaDocumentReader读取文件
        TikaDocumentReader tikaDocumentReader = new TikaDocumentReader(resource);
        List<Document> documents;
        try {
            documents = tikaDocumentReader.read();
        } catch (StackOverflowError e) {
            log.error(
                    "TikaDocumentReader read failed due to StackOverflowError, possibly caused by problematic regex in Tika when processing file: {}",
                    knowledge.getFilePath(), e);
            throw new RuntimeException(
                    "File processing failed due to stack overflow, possibly caused by complex document structure or Tika internal regex issue: "
                            + knowledge.getFilePath(),
                    e);
        } catch (Exception e) {
            log.error("TikaDocumentReader read failed for file: {}", knowledge.getFilePath(), e);
            throw new RuntimeException("File processing failed: " + knowledge.getFilePath(), e);
        }

        try {
            // 根据知识配置的切割方式获取对应的 TextSplitter
            String splitterType = knowledge.getSplitterType();
            if (!StringUtils.hasText(splitterType)) {
                splitterType = SplitterType.TOKEN.getValue(); // 默认使用 token 切割
                log.warn("Splitter type is empty for knowledgeId: {}, using default: token", knowledge.getId());
            }

            TextSplitter textSplitter = textSplitterFactory.getSplitter(splitterType);
            log.info("Using splitter type: {} for knowledgeId: {}", splitterType, knowledge.getId());

            return textSplitter.apply(documents);
        } catch (StackOverflowError e) {
            log.error("TextSplitter apply failed due to StackOverflowError for file: {}", knowledge.getFilePath(), e);
            throw new RuntimeException(
                    "Text splitting failed due to stack overflow, possibly caused by complex document content: "
                            + knowledge.getFilePath(),
                    e);
        } catch (Exception e) {
            log.error("TextSplitter apply failed for file: {}", knowledge.getFilePath(), e);
            throw new RuntimeException("Text splitting failed: " + knowledge.getFilePath(), e);
        }
    }

    // ... 现有代码 ...
}

// 数据库迁移SQL
ALTER TABLE agent_knowledge 
ADD COLUMN splitter_type VARCHAR(50) DEFAULT 'token' COMMENT '文本切割方式：token, recursive' 
AFTER file_type;

CREATE INDEX idx_splitter_type ON agent_knowledge(splitter_type);
```

**前端页面示例**:

```html
<!-- 知识管理页面 - 切割方式选择器 -->
<div class="form-group">
    <label>文本切割方式</label>
    <select class="form-control" v-model="knowledge.splitterType">
        <option value="token">Token 切割（推荐）</option>
        <option value="recursive">递归切割</option>
    </select>
    <small class="text-muted">
        Token 切割：按照 token 数量进行切割，适合大多数文档<br>
        递归切割：按照段落结构进行切割，适合结构化文档
    </small>
</div>
```

**注意事项**:
- 保持向后兼容性，对于没有设置 `splitterType` 的旧数据，默认使用 "token" 切割方式
- 确保前端选择的切割方式与后端定义的 `SplitterType` 枚举值一致
- 考虑添加切割方式的说明文档，帮助用户选择合适的切割方式
- 可以考虑添加更多切割方式，如 "character" 切割等
- 在 `TextSplitterFactory` 中添加日志，记录使用的切割方式，便于调试

---

## 统计总结

| 统计项 | 数量 |
|--------|------|
| TODO总数 | 5个 |
| 涉及文件 | 5个 |
| 高优先级 | 2个 |
| 中等优先级 | 3个 |
| 配置重构 | 1个 |
| 性能优化 | 1个 |
| 功能增强 | 2个 |
| 功能实现 | 1个 |

---

## 优先级排序

### 高优先级
1. **OssFileStorageServiceImpl.java** - getFileResource方法未实现，影响功能完整性
2. **PlanExecutorNode.java** - 性能优化，避免重复校验

### 中等优先级
3. **McpServerConfig.java** - 配置重构（有时间标记：2025/12/08）
4. **BusinessKnowledgeService.java** - 添加分页查询方法
5. **TextSplitterFactory.java** - 改造AgentKnowledgeResourceManager支持用户选择切割方式

---

## 建议处理顺序

1. 优先实现 `OssFileStorageServiceImpl.getFileResource` 方法
2. 优化 `PlanExecutorNode` 的校验逻辑位置
3. 添加 `BusinessKnowledgeService` 分页查询方法
4. 改造 `TextSplitterFactory` 和 `AgentKnowledgeResourceManager`
5. 在2025年12月8日前完成 `McpServerConfig` 的合并迁移

---

*生成时间: 2026-02-03*
*最后更新: 2026-02-03*


