# 预设问题管理功能增强实现计划

## 一、架构设计

### 1.1 设计模式应用

**策略模式(Database Dialect Strategy)**
- 利用现有的 `SqlDialectResolver` 工具类处理MySQL和达梦数据库分页语法差异
- 在Mapper层使用 `${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, size)}` 动态适配

**模板方法模式(Service Layer)**
- 参考现有 `AgentKnowledgeServiceImpl` 的分页实现模式
- 统一的分页查询流程：参数校验 → 计算偏移量 → 查询总数 → 分页查询 → 结果封装

### 1.2 可复用组件设计

创建通用分页组件 `Pagination.vue`,支持:
- 自定义每页条数选项
- 总记录数显示
- 页码跳转
- 响应式数据绑定

## 二、后端实现

### 2.1 DTO层改造

**文件**: `data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/dto/agent/PresetQuestionQueryDTO.java` (新建)

```java
package com.audaque.cloud.ai.dataagent.dto.agent;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PresetQuestionQueryDTO {
    
    @NotNull(message = "agentId cannot be null")
    private Long agentId;
    
    // Search by question content (fuzzy search)
    private String keyword;
    
    // Filter by active status: null-all, true-active only, false-inactive only
    private Boolean isActive;
    
    // Date range filter
    private String createTimeStart;
    private String createTimeEnd;
    
    // Pagination parameters
    @NotNull(message = "pageNum cannot be null")
    @Min(value = 1, message = "pageNum must be greater than 0")
    private Integer pageNum = 1;
    
    @NotNull(message = "pageSize cannot be null")
    @Min(value = 1, message = "pageSize must be greater than 0")
    private Integer pageSize = 10;
}
```

**文件**: `data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/dto/agent/BatchDeleteDTO.java` (新建)

```java
package com.audaque.cloud.ai.dataagent.dto.agent;

import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import java.util.List;

@Data
public class BatchDeleteDTO {
    @NotNull(message = "agentId cannot be null")
    private Long agentId;
    
    @NotEmpty(message = "ids cannot be empty")
    private List<Long> ids;
}
```

### 2.2 Mapper层改造

**文件**: `data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/mapper/AgentPresetQuestionMapper.java`

需要添加的方法:

```java
// 分页查询 - 使用SqlDialectResolver适配数据库差异
@Select("""
    <script>
    SELECT * FROM agent_preset_question
    WHERE agent_id = #{queryDTO.agentId}
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND question LIKE CONCAT('%', #{queryDTO.keyword}, '%')
    </if>
    <if test="queryDTO.isActive != null">
        AND is_active = #{queryDTO.isActive}
    </if>
    <if test="queryDTO.createTimeStart != null and queryDTO.createTimeStart != ''">
        AND create_time &gt;= #{queryDTO.createTimeStart}
    </if>
    <if test="queryDTO.createTimeEnd != null and queryDTO.createTimeEnd != ''">
        AND create_time &lt;= #{queryDTO.createTimeEnd}
    </if>
    ORDER BY sort_order ASC, id ASC
    ${@com.audaque.cloud.ai.dataagent.util.SqlDialectResolver@limit(offset, queryDTO.pageSize)}
    </script>
    """)
List<AgentPresetQuestion> selectByConditionsWithPage(
    @Param("queryDTO") PresetQuestionQueryDTO queryDTO,
    @Param("offset") Integer offset
);

// 统计总数
@Select("""
    <script>
    SELECT COUNT(*) FROM agent_preset_question
    WHERE agent_id = #{queryDTO.agentId}
    <if test="queryDTO.keyword != null and queryDTO.keyword != ''">
        AND question LIKE CONCAT('%', #{queryDTO.keyword}, '%')
    </if>
    <if test="queryDTO.isActive != null">
        AND is_active = #{queryDTO.isActive}
    </if>
    <if test="queryDTO.createTimeStart != null and queryDTO.createTimeStart != ''">
        AND create_time &gt;= #{queryDTO.createTimeStart}
    </if>
    <if test="queryDTO.createTimeEnd != null and queryDTO.createTimeEnd != ''">
        AND create_time &lt;= #{queryDTO.createTimeEnd}
    </if>
    </script>
    """)
Long countByConditions(@Param("queryDTO") PresetQuestionQueryDTO queryDTO);

// 批量删除
@Delete("""
    <script>
    DELETE FROM agent_preset_question
    WHERE agent_id = #{agentId}
    AND id IN
    <foreach collection="ids" item="id" open="(" close=")" separator=",">
        #{id}
    </foreach>
    </script>
    """)
int batchDeleteByIds(@Param("agentId") Long agentId, @Param("ids") List<Long> ids);
```

### 2.3 Service层改造

**文件**: `data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/service/agent/AgentPresetQuestionService.java`

添加接口方法:

```java
/**
 * Page query preset questions
 */
PageResult<AgentPresetQuestion> queryByConditionsWithPage(PresetQuestionQueryDTO queryDTO);

/**
 * Batch delete preset questions
 */
boolean batchDelete(BatchDeleteDTO deleteDTO);
```

**文件**: `data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/service/agent/AgentPresetQuestionServiceImpl.java`

实现逻辑:

```java
@Override
public PageResult<AgentPresetQuestion> queryByConditionsWithPage(PresetQuestionQueryDTO queryDTO) {
    log.info("Page query preset questions: agentId={}, pageNum={}, pageSize={}, keyword={}", 
        queryDTO.getAgentId(), queryDTO.getPageNum(), queryDTO.getPageSize(), queryDTO.getKeyword());
    
    // Validate parameters
    if (queryDTO.getAgentId() == null) {
        log.error("agentId cannot be null");
        throw new IllegalArgumentException("agentId cannot be null");
    }
    
    // Calculate offset
    int offset = (queryDTO.getPageNum() - 1) * queryDTO.getPageSize();
    
    // Query total count
    Long total = agentPresetQuestionMapper.countByConditions(queryDTO);
    log.debug("Total count: {}", total);
    
    // Query page data
    List<AgentPresetQuestion> dataList = agentPresetQuestionMapper.selectByConditionsWithPage(queryDTO, offset);
    log.info("Query completed: returned {} records", dataList.size());
    
    // Build result
    PageResult<AgentPresetQuestion> pageResult = new PageResult<>();
    pageResult.setData(dataList);
    pageResult.setTotal(total);
    pageResult.setPageNum(queryDTO.getPageNum());
    pageResult.setPageSize(queryDTO.getPageSize());
    pageResult.calculateTotalPages();
    
    return pageResult;
}

@Override
@Transactional
public boolean batchDelete(BatchDeleteDTO deleteDTO) {
    log.info("Batch deleting preset questions: agentId={}, count={}", 
        deleteDTO.getAgentId(), deleteDTO.getIds().size());
    
    // Validate parameters
    if (deleteDTO.getAgentId() == null || deleteDTO.getIds() == null || deleteDTO.getIds().isEmpty()) {
        log.error("Invalid batch delete parameters");
        throw new IllegalArgumentException("agentId and ids cannot be null or empty");
    }
    
    try {
        int deletedCount = agentPresetQuestionMapper.batchDeleteByIds(deleteDTO.getAgentId(), deleteDTO.getIds());
        log.info("Successfully deleted {} preset questions", deletedCount);
        return deletedCount > 0;
    } catch (Exception e) {
        log.error("Batch delete failed: agentId={}, error={}", deleteDTO.getAgentId(), e.getMessage(), e);
        throw new RuntimeException("Batch delete failed: " + e.getMessage(), e);
    }
}
```

### 2.4 Controller层改造

**文件**: `data-agent-management/src/main/java/com/audaque/cloud/ai/dataagent/controller/AgentPresetQuestionController.java`

添加新接口:

```java
/**
 * Page query preset questions with filters
 */
@PostMapping("/{agentId}/preset-questions/page")
public PageResponse<List<AgentPresetQuestion>> queryPresetQuestionsPage(
        @PathVariable(value = "agentId") Long agentId,
        @Valid @RequestBody PresetQuestionQueryDTO queryDTO) {
    try {
        log.info("Page query request: agentId={}, pageNum={}, pageSize={}", 
            agentId, queryDTO.getPageNum(), queryDTO.getPageSize());
        
        // Set agentId from path variable
        queryDTO.setAgentId(agentId);
        
        PageResult<AgentPresetQuestion> pageResult = presetQuestionService.queryByConditionsWithPage(queryDTO);
        
        return PageResponse.success(
            pageResult.getData(),
            pageResult.getTotal(),
            pageResult.getPageNum(),
            pageResult.getPageSize(),
            pageResult.getTotalPages()
        );
    } catch (IllegalArgumentException e) {
        log.error("Invalid query parameters for agent {}: {}", agentId, e.getMessage());
        return PageResponse.pageError("Invalid parameters: " + e.getMessage());
    } catch (Exception e) {
        log.error("Error querying preset questions page for agent {}", agentId, e);
        return PageResponse.pageError("Query failed: " + e.getMessage());
    }
}

/**
 * Batch delete preset questions
 */
@DeleteMapping("/{agentId}/preset-questions/batch")
public ResponseEntity<Map<String, String>> batchDeletePresetQuestions(
        @PathVariable(value = "agentId") Long agentId,
        @Valid @RequestBody BatchDeleteDTO deleteDTO) {
    try {
        log.info("Batch delete request: agentId={}, count={}", agentId, deleteDTO.getIds().size());
        
        // Set agentId from path variable
        deleteDTO.setAgentId(agentId);
        
        boolean success = presetQuestionService.batchDelete(deleteDTO);
        
        if (success) {
            return ResponseEntity.ok(Map.of("message", "Batch delete successful"));
        } else {
            return ResponseEntity.internalServerError()
                .body(Map.of("error", "Batch delete failed: no records deleted"));
        }
    } catch (IllegalArgumentException e) {
        log.error("Invalid batch delete parameters for agent {}: {}", agentId, e.getMessage());
        return ResponseEntity.badRequest()
            .body(Map.of("error", "Invalid parameters: " + e.getMessage()));
    } catch (Exception e) {
        log.error("Error batch deleting preset questions for agent {}", agentId, e);
        return ResponseEntity.internalServerError()
            .body(Map.of("error", "Batch delete failed: " + e.getMessage()));
    }
}
```

## 三、前端实现

### 3.1 通用分页组件

**文件**: `data-agent-frontend/src/components/common/Pagination.vue` (新建目录和文件)

```vue
<template>
  <div v-if="total > 0" class="pagination-container">
    <el-pagination
      v-model:current-page="currentPage"
      v-model:page-size="currentPageSize"
      :page-sizes="pageSizes"
      :total="total"
      :layout="layout"
      :background="background"
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
    />
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, watch, PropType } from 'vue';

export default defineComponent({
  name: 'Pagination',
  props: {
    total: {
      type: Number,
      required: true,
      default: 0,
    },
    pageNum: {
      type: Number,
      default: 1,
    },
    pageSize: {
      type: Number,
      default: 10,
    },
    pageSizes: {
      type: Array as PropType<number[]>,
      default: () => [10, 20, 50, 100],
    },
    layout: {
      type: String,
      default: 'total, sizes, prev, pager, next, jumper',
    },
    background: {
      type: Boolean,
      default: true,
    },
  },
  emits: ['change', 'update:pageNum', 'update:pageSize'],
  setup(props, { emit }) {
    const currentPage = ref(props.pageNum);
    const currentPageSize = ref(props.pageSize);

    // Watch props changes
    watch(() => props.pageNum, (newVal) => {
      currentPage.value = newVal;
    });

    watch(() => props.pageSize, (newVal) => {
      currentPageSize.value = newVal;
    });

    const handleSizeChange = (size: number) => {
      currentPageSize.value = size;
      currentPage.value = 1; // Reset to first page
      emitChange();
    };

    const handleCurrentChange = (page: number) => {
      currentPage.value = page;
      emitChange();
    };

    const emitChange = () => {
      emit('update:pageNum', currentPage.value);
      emit('update:pageSize', currentPageSize.value);
      emit('change', {
        pageNum: currentPage.value,
        pageSize: currentPageSize.value,
      });
    };

    return {
      currentPage,
      currentPageSize,
      handleSizeChange,
      handleCurrentChange,
    };
  },
});
</script>

<style scoped>
.pagination-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px 0;
  margin-top: 20px;
}
</style>
```

### 3.2 Service层改造

**文件**: `data-agent-frontend/src/services/presetQuestion.ts`

添加类型定义和新方法:

```typescript
// 添加分页查询参数接口
interface PresetQuestionQueryParams {
  pageNum: number;
  pageSize: number;
  keyword?: string;
  isActive?: boolean;
  createTimeStart?: string;
  createTimeEnd?: string;
}

// 添加分页响应接口
interface PageResponse<T> {
  success: boolean;
  message: string;
  data: T[];
  total: number;
  pageNum: number;
  pageSize: number;
  totalPages: number;
}

class PresetQuestionService {
  // 保留原有方法...

  /**
   * Page query preset questions
   */
  async queryPage(
    agentId: number,
    params: PresetQuestionQueryParams
  ): Promise<PageResponse<PresetQuestion>> {
    try {
      const response = await axios.post<PageResponse<PresetQuestion>>(
        `${API_BASE_URL}/${agentId}/preset-questions/page`,
        params
      );
      return response.data;
    } catch (error) {
      console.error('Query preset questions page failed:', error);
      throw error;
    }
  }

  /**
   * Batch delete preset questions
   */
  async batchDelete(agentId: number, ids: number[]): Promise<boolean> {
    try {
      const response = await axios.delete(
        `${API_BASE_URL}/${agentId}/preset-questions/batch`,
        { data: { ids } }
      );
      return response.status === 200;
    } catch (error) {
      console.error('Batch delete preset questions failed:', error);
      throw error;
    }
  }
}

export type { PresetQuestionQueryParams, PageResponse };
```

### 3.3 PresetsConfig.vue改造

**文件**: `data-agent-frontend/src/components/agent/PresetsConfig.vue`

主要改动点:

1. **导入分页组件**:
```typescript
import Pagination from '@/components/common/Pagination.vue';
```

2. **添加搜索和筛选表单**:
```vue
<!-- 搜索和筛选区域 -->
<el-form :inline="true" :model="searchForm" style="margin-bottom: 20px">
  <el-form-item label="关键词">
    <el-input
      v-model="searchForm.keyword"
      placeholder="搜索问题内容"
      clearable
      @clear="handleSearch"
    />
  </el-form-item>
  <el-form-item label="状态">
    <el-select v-model="searchForm.isActive" placeholder="全部" clearable>
      <el-option label="启用" :value="true" />
      <el-option label="禁用" :value="false" />
    </el-select>
  </el-form-item>
  <el-form-item label="创建时间">
    <el-date-picker
      v-model="searchForm.dateRange"
      type="daterange"
      range-separator="-"
      start-placeholder="开始日期"
      end-placeholder="结束日期"
      value-format="YYYY-MM-DD"
    />
  </el-form-item>
  <el-form-item>
    <el-button type="primary" @click="handleSearch">搜索</el-button>
    <el-button @click="handleReset">重置</el-button>
  </el-form-item>
</el-form>
```

3. **添加批量操作按钮和选择列**:
```vue
<el-row style="margin-bottom: 15px">
  <el-col :span="12">
    <el-button
      v-if="selectedRows.length > 0"
      @click="handleBatchDelete"
      type="danger"
      plain
      :icon="Delete"
    >
      批量删除 ({{ selectedRows.length }})
    </el-button>
  </el-col>
</el-row>

<el-table
  :data="presetQuestionList"
  @selection-change="handleSelectionChange"
  style="width: 100%"
  border
>
  <el-table-column type="selection" width="55" />
  <!-- 其他列... -->
</el-table>
```

4. **添加分页组件**:
```vue
<Pagination
  v-model:page-num="pagination.pageNum"
  v-model:page-size="pagination.pageSize"
  :total="pagination.total"
  :page-sizes="[10, 20, 50, 100]"
  @change="loadPresetQuestions"
/>
```

5. **Setup脚本改造**:
```typescript
import { Delete } from '@element-plus/icons-vue';

const searchForm = ref({
  keyword: '',
  isActive: null as boolean | null,
  dateRange: [] as string[],
});

const pagination = ref({
  pageNum: 1,
  pageSize: 10,
  total: 0,
});

const selectedRows: Ref<PresetQuestion[]> = ref([]);

const handleSelectionChange = (selection: PresetQuestion[]) => {
  selectedRows.value = selection;
};

const loadPresetQuestions = async () => {
  try {
    const params: PresetQuestionQueryParams = {
      pageNum: pagination.value.pageNum,
      pageSize: pagination.value.pageSize,
      keyword: searchForm.value.keyword || undefined,
      isActive: searchForm.value.isActive ?? undefined,
    };

    if (searchForm.value.dateRange && searchForm.value.dateRange.length === 2) {
      params.createTimeStart = searchForm.value.dateRange[0];
      params.createTimeEnd = searchForm.value.dateRange[1];
    }

    const response = await presetQuestionService.queryPage(props.agentId, params);
    
    if (response.success) {
      presetQuestionList.value = response.data;
      pagination.value.total = response.total;
    } else {
      ElMessage.error(response.message || 'Failed to load preset questions');
    }
  } catch (error) {
    ElMessage.error('Failed to load preset questions');
    console.error('Load preset questions failed:', error);
  }
};

const handleSearch = () => {
  pagination.value.pageNum = 1; // Reset to first page
  loadPresetQuestions();
};

const handleReset = () => {
  searchForm.value = {
    keyword: '',
    isActive: null,
    dateRange: [],
  };
  handleSearch();
};

const handleBatchDelete = async () => {
  if (selectedRows.value.length === 0) {
    ElMessage.warning('Please select records to delete');
    return;
  }

  try {
    await ElMessageBox.confirm(
      `Are you sure to delete ${selectedRows.value.length} preset question(s)?`,
      'Confirm Batch Delete',
      {
        confirmButtonText: 'Confirm',
        cancelButtonText: 'Cancel',
        type: 'warning',
      }
    );

    const ids = selectedRows.value.map(row => row.id).filter(id => id !== undefined) as number[];
    const result = await presetQuestionService.batchDelete(props.agentId, ids);
    
    if (result) {
      ElMessage.success('Batch delete successful');
      selectedRows.value = [];
      await loadPresetQuestions();
    } else {
      ElMessage.error('Batch delete failed');
    }
  } catch (error: any) {
    if (error !== 'cancel') {
      ElMessage.error('Batch delete failed');
      console.error('Batch delete error:', error);
    }
  }
};
```

## 四、数据库兼容性验证

### 4.1 SQL语法验证点

**MySQL语法**:
```sql
-- 分页
SELECT * FROM agent_preset_question WHERE ... LIMIT 10, 20

-- CONCAT函数
WHERE question LIKE CONCAT('%', 'keyword', '%')
```

**达梦数据库语法**:
```sql
-- 分页 (通过SqlDialectResolver自动转换)
SELECT * FROM agent_preset_question WHERE ... LIMIT 20 OFFSET 10

-- CONCAT函数 (兼容)
WHERE question LIKE CONCAT('%', 'keyword', '%')
```

### 4.2 SqlDialectResolver验证

已有工具类 `com.audaque.cloud.ai.dataagent.util.SqlDialectResolver`:
- `limit(offset, size)` 方法根据 `spring.datasource.platform` 配置自动适配
- MySQL: `LIMIT offset, size`
- 达梦: `LIMIT size OFFSET offset`

## 五、日志输出增强

所有关键操作添加详细日志:

**查询操作**:
```java
log.info("Page query preset questions: agentId={}, pageNum={}, pageSize={}, keyword={}", ...);
log.debug("Total count: {}", total);
log.info("Query completed: returned {} records", dataList.size());
```

**删除操作**:
```java
log.info("Batch deleting preset questions: agentId={}, count={}", ...);
log.info("Successfully deleted {} preset questions", deletedCount);
log.error("Batch delete failed: agentId={}, error={}", agentId, e.getMessage(), e);
```

**异常处理**:
```java
log.error("Invalid query parameters for agent {}: {}", agentId, e.getMessage());
log.error("Error querying preset questions page for agent {}", agentId, e);
```

## 六、代码鲁棒性保障

### 6.1 参数校验
- 使用 `@Valid` 和 `@NotNull`、`@Min` 等注解进行参数验证
- Service层额外校验关键参数,抛出 `IllegalArgumentException`

### 6.2 异常处理
- Controller层捕获所有异常,区分参数异常和系统异常
- Service层使用 `@Transactional` 保证事务一致性
- 前端统一错误提示,避免系统崩溃

### 6.3 边界处理
- 空数据处理:分页组件自动隐藏
- 最后一页删除后自动跳转前一页
- 批量删除前确认对话框

### 6.4 数据验证
- 日期范围验证
- ID列表非空验证
- agentId一致性验证

## 七、测试验证清单

### 7.1 单元测试
- [ ] PresetQuestionQueryDTO参数验证测试
- [ ] SqlDialectResolver分页语法测试(MySQL和达梦)
- [ ] Mapper层分页查询测试
- [ ] Service层批量删除事务测试

### 7.2 集成测试
- [ ] 分页查询API测试(各种参数组合)
- [ ] 批量删除API测试
- [ ] 跨数据库兼容性测试

### 7.3 前端测试
- [ ] 分页组件交互测试
- [ ] 搜索过滤功能测试
- [ ] 批量删除确认流程测试
- [ ] 边界情况测试(空数据、最后一页等)

## 八、实施顺序

1. 创建DTO类(PresetQuestionQueryDTO、BatchDeleteDTO)
2. 修改Mapper层,添加分页和批量删除方法
3. 修改Service接口和实现类
4. 修改Controller,添加新接口
5. 创建前端通用分页组件
6. 修改前端Service层
7. 改造PresetsConfig.vue
8. 编写单元测试
9. 本地测试(MySQL和达梦数据库)
10. 集成测试和代码审查

## 九、注意事项

1. **数据库兼容性**: 确保在MySQL和达梦两种数据库环境下都进行充分测试
2. **事务处理**: 批量删除使用 `@Transactional` 保证原子性
3. **日志语言**: 所有日志使用英文,符合项目规范
4. **代码注释**: 代码注释使用英文
5. **错误信息**: 用户可见的错误信息使用中文
6. **性能优化**: 分页查询避免查询所有数据,减少内存占用
7. **安全性**: 防止SQL注入,使用参数化查询
8. **向后兼容**: 保留原有的list和batchSave接口,不影响现有功能
