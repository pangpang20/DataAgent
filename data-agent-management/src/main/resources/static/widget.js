(function () {
    "use strict";/**
* @vue/shared v3.5.27
* (c) 2026-chenyunliang and Vue contributors
* @license MIT
**/function tt(e) { const t = Object.create(null); for (const n of e.split(",")) t[n] = 1; return n => n in t } const W = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, Ft = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], ie = () => { }, Tr = () => !1, Gt = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Tn = e => e.startsWith("onUpdate:"), ne = Object.assign, ws = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, vc = Object.prototype.hasOwnProperty, k = (e, t) => vc.call(e, t), $ = Array.isArray, _t = e => Rn(e) === "[object Map]", Rr = e => Rn(e) === "[object Set]", M = e => typeof e == "function", ee = e => typeof e == "string", ut = e => typeof e == "symbol", G = e => e !== null && typeof e == "object", Ss = e => (G(e) || M(e)) && M(e.then) && M(e.catch), Vr = Object.prototype.toString, Rn = e => Vr.call(e), xs = e => Rn(e).slice(8, -1), Ar = e => Rn(e) === "[object Object]", Ds = e => ee(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Xt = tt(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Nc = tt("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), Vn = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, Oc = /-\w/g, Ve = Vn(e => e.replace(Oc, t => t.slice(1).toUpperCase())), wc = /\B([A-Z])/g, nt = Vn(e => e.replace(wc, "-$1").toLowerCase()), An = Vn(e => e.charAt(0).toUpperCase() + e.slice(1)), vt = Vn(e => e ? `on${An(e)}` : ""), ft = (e, t) => !Object.is(e, t), $t = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, Pn = (e, t, n, s = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: s, value: n }) }, Cs = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let Pr; const Yt = () => Pr || (Pr = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function dt(e) { if ($(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n], r = ee(s) ? Cc(s) : dt(s); if (r) for (const o in r) t[o] = r[o] } return t } else if (ee(e) || G(e)) return e } const Sc = /;(?![^(]*\))/g, xc = /:([^]+)/, Dc = /\/\*[^]*?\*\//g; function Cc(e) { const t = {}; return e.replace(Dc, "").split(Sc).forEach(n => { if (n) { const s = n.split(xc); s.length > 1 && (t[s[0].trim()] = s[1].trim()) } }), t } function Zt(e) { let t = ""; if (ee(e)) t = e; else if ($(e)) for (let n = 0; n < e.length; n++) { const s = Zt(e[n]); s && (t += s + " ") } else if (G(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } const Tc = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Rc = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", Vc = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", Ac = tt(Tc), Pc = tt(Rc), Fc = tt(Vc), $c = tt("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"); function Fr(e) { return !!e || e === "" } const $r = e => !!(e && e.__v_isRef === !0), Fn = e => ee(e) ? e : e == null ? "" : $(e) || G(e) && (e.toString === Vr || !M(e.toString)) ? $r(e) ? Fn(e.value) : JSON.stringify(e, Ir, 2) : String(e), Ir = (e, t) => $r(t) ? Ir(e, t.value) : _t(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [s, r], o) => (n[Ts(s, o) + " =>"] = r, n), {}) } : Rr(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => Ts(n)) } : ut(t) ? Ts(t) : G(t) && !$(t) && !Ar(t) ? String(t) : t, Ts = (e, t = "") => { var n; return ut(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.5.27
* (c) 2026-chenyunliang and Vue contributors
* @license MIT
**/function Ae(e, ...t) { console.warn(`[Vue warn] ${e}`, ...t) } let Ee; class Ic { constructor(t = !1) { this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Ee, !t && Ee && (this.index = (Ee.scopes || (Ee.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { const n = Ee; try { return Ee = this, t() } finally { Ee = n } } else process.env.NODE_ENV !== "production" && Ae("cannot run an inactive effect scope.") } on() { ++this._on === 1 && (this.prevScope = Ee, Ee = this) } off() { this._on > 0 && --this._on === 0 && (Ee = this.prevScope, this.prevScope = void 0) } stop(t) { if (this._active) { this._active = !1; let n, s; for (n = 0, s = this.effects.length; n < s; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, s = this.scopes.length; n < s; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const r = this.parent.scopes.pop(); r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) } this.parent = void 0 } } } function Mc() { return Ee } let q; const Rs = new WeakSet; class Mr { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Ee && Ee.active && Ee.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, Rs.has(this) && (Rs.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Lr(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, Kr(this), Ur(this); const t = q, n = Pe; q = this, Pe = !0; try { return this.fn() } finally { process.env.NODE_ENV !== "production" && q !== this && Ae("Active effect was not restored correctly - this is likely a Vue internal bug."), Hr(this), q = t, Pe = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)Fs(t); this.deps = this.depsTail = void 0, Kr(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? Rs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Ps(this) && this.run() } get dirty() { return Ps(this) } } let jr = 0, Qt, en; function Lr(e, t = !1) { if (e.flags |= 8, t) { e.next = en, en = e; return } e.next = Qt, Qt = e } function Vs() { jr++ } function As() { if (--jr > 0) return; if (en) { let t = en; for (en = void 0; t;) { const n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; Qt;) { let t = Qt; for (Qt = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (s) { e || (e = s) } t = n } } if (e) throw e } function Ur(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function Hr(e) { let t, n = e.depsTail, s = n; for (; s;) { const r = s.prevDep; s.version === -1 ? (s === n && (n = r), Fs(s), jc(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r } e.deps = t, e.depsTail = n } function Ps(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Br(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Br(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === tn) || (e.globalVersion = tn, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Ps(e)))) return; e.flags |= 2; const t = e.dep, n = q, s = Pe; q = e, Pe = !0; try { Ur(e); const r = e.fn(e._value); (t.version === 0 || ft(r, e._value)) && (e.flags |= 128, e._value = r, t.version++) } catch (r) { throw t.version++, r } finally { q = n, Pe = s, Hr(e), e.flags &= -3 } } function Fs(e, t = !1) { const { dep: n, prevSub: s, nextSub: r } = e; if (s && (s.nextSub = r, e.prevSub = void 0), r && (r.prevSub = s, e.nextSub = void 0), process.env.NODE_ENV !== "production" && n.subsHead === e && (n.subsHead = r), n.subs === e && (n.subs = s, !s && n.computed)) { n.computed.flags &= -5; for (let o = n.computed.deps; o; o = o.nextDep)Fs(o, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function jc(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } let Pe = !0; const kr = []; function Fe() { kr.push(Pe), Pe = !1 } function $e() { const e = kr.pop(); Pe = e === void 0 ? !0 : e } function Kr(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const n = q; q = void 0; try { t() } finally { q = n } } } let tn = 0; class Lc { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class $s { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, process.env.NODE_ENV !== "production" && (this.subsHead = void 0) } track(t) { if (!q || !Pe || q === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== q) n = this.activeLink = new Lc(q, this), q.deps ? (n.prevDep = q.depsTail, q.depsTail.nextDep = n, q.depsTail = n) : q.deps = q.depsTail = n, Wr(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const s = n.nextDep; s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = q.depsTail, n.nextDep = void 0, q.depsTail.nextDep = n, q.depsTail = n, q.deps === n && (q.deps = s) } return process.env.NODE_ENV !== "production" && q.onTrack && q.onTrack(ne({ effect: q }, t)), n } trigger(t) { this.version++, tn++, this.notify(t) } notify(t) { Vs(); try { if (process.env.NODE_ENV !== "production") for (let n = this.subsHead; n; n = n.nextSub)n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(ne({ effect: n.sub }, t)); for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { As() } } } function Wr(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let s = t.deps; s; s = s.nextDep)Wr(s) } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), process.env.NODE_ENV !== "production" && e.dep.subsHead === void 0 && (e.dep.subsHead = e), e.dep.subs = e } } const Is = new WeakMap, Nt = Symbol(process.env.NODE_ENV !== "production" ? "Object iterate" : ""), Ms = Symbol(process.env.NODE_ENV !== "production" ? "Map keys iterate" : ""), nn = Symbol(process.env.NODE_ENV !== "production" ? "Array iterate" : ""); function ce(e, t, n) { if (Pe && q) { let s = Is.get(e); s || Is.set(e, s = new Map); let r = s.get(n); r || (s.set(n, r = new $s), r.map = s, r.key = n), process.env.NODE_ENV !== "production" ? r.track({ target: e, type: t, key: n }) : r.track() } } function Ke(e, t, n, s, r, o) { const i = Is.get(e); if (!i) { tn++; return } const c = l => { l && (process.env.NODE_ENV !== "production" ? l.trigger({ target: e, type: t, key: n, newValue: s, oldValue: r, oldTarget: o }) : l.trigger()) }; if (Vs(), t === "clear") i.forEach(c); else { const l = $(e), d = l && Ds(n); if (l && n === "length") { const a = Number(s); i.forEach((f, g) => { (g === "length" || g === nn || !ut(g) && g >= a) && c(f) }) } else switch ((n !== void 0 || i.has(void 0)) && c(i.get(n)), d && c(i.get(nn)), t) { case "add": l ? d && c(i.get("length")) : (c(i.get(Nt)), _t(e) && c(i.get(Ms))); break; case "delete": l || (c(i.get(Nt)), _t(e) && c(i.get(Ms))); break; case "set": _t(e) && c(i.get(Nt)); break } } As() } function It(e) { const t = H(e); return t === e ? t : (ce(t, "iterate", nn), de(e) ? t : t.map(Me)) } function $n(e) { return ce(e = H(e), "iterate", nn), e } function pt(e, t) { return Ie(e) ? Mt(ht(e) ? Me(t) : t) : Me(t) } const Uc = { __proto__: null, [Symbol.iterator]() { return js(this, Symbol.iterator, e => pt(this, e)) }, concat(...e) { return It(this).concat(...e.map(t => $(t) ? It(t) : t)) }, entries() { return js(this, "entries", e => (e[1] = pt(this, e[1]), e)) }, every(e, t) { return st(this, "every", e, t, void 0, arguments) }, filter(e, t) { return st(this, "filter", e, t, n => n.map(s => pt(this, s)), arguments) }, find(e, t) { return st(this, "find", e, t, n => pt(this, n), arguments) }, findIndex(e, t) { return st(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return st(this, "findLast", e, t, n => pt(this, n), arguments) }, findLastIndex(e, t) { return st(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return st(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return Ls(this, "includes", e) }, indexOf(...e) { return Ls(this, "indexOf", e) }, join(e) { return It(this).join(e) }, lastIndexOf(...e) { return Ls(this, "lastIndexOf", e) }, map(e, t) { return st(this, "map", e, t, void 0, arguments) }, pop() { return sn(this, "pop") }, push(...e) { return sn(this, "push", e) }, reduce(e, ...t) { return qr(this, "reduce", e, t) }, reduceRight(e, ...t) { return qr(this, "reduceRight", e, t) }, shift() { return sn(this, "shift") }, some(e, t) { return st(this, "some", e, t, void 0, arguments) }, splice(...e) { return sn(this, "splice", e) }, toReversed() { return It(this).toReversed() }, toSorted(e) { return It(this).toSorted(e) }, toSpliced(...e) { return It(this).toSpliced(...e) }, unshift(...e) { return sn(this, "unshift", e) }, values() { return js(this, "values", e => pt(this, e)) } }; function js(e, t, n) { const s = $n(e), r = s[t](); return s !== e && !de(e) && (r._next = r.next, r.next = () => { const o = r._next(); return o.done || (o.value = n(o.value)), o }), r } const Hc = Array.prototype; function st(e, t, n, s, r, o) { const i = $n(e), c = i !== e && !de(e), l = i[t]; if (l !== Hc[t]) { const f = l.apply(e, o); return c ? Me(f) : f } let d = n; i !== e && (c ? d = function (f, g) { return n.call(this, pt(e, f), g, e) } : n.length > 2 && (d = function (f, g) { return n.call(this, f, g, e) })); const a = l.call(i, d, s); return c && r ? r(a) : a } function qr(e, t, n, s) { const r = $n(e); let o = n; return r !== e && (de(e) ? n.length > 3 && (o = function (i, c, l) { return n.call(this, i, c, l, e) }) : o = function (i, c, l) { return n.call(this, i, pt(e, c), l, e) }), r[t](o, ...s) } function Ls(e, t, n) { const s = H(e); ce(s, "iterate", nn); const r = s[t](...n); return (r === -1 || r === !1) && Un(n[0]) ? (n[0] = H(n[0]), s[t](...n)) : r } function sn(e, t, n = []) { Fe(), Vs(); const s = H(e)[t].apply(e, n); return As(), $e(), s } const Bc = tt("__proto__,__v_isRef,__isVue"), Jr = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(ut)); function kc(e) { ut(e) || (e = String(e)); const t = H(this); return ce(t, "has", e), t.hasOwnProperty(e) } class zr { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, s) { if (n === "__v_skip") return t.__v_skip; const r = this._isReadonly, o = this._isShallow; if (n === "__v_isReactive") return !r; if (n === "__v_isReadonly") return r; if (n === "__v_isShallow") return o; if (n === "__v_raw") return s === (r ? o ? to : eo : o ? Qr : Zr).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0; const i = $(t); if (!r) { let l; if (i && (l = Uc[n])) return l; if (n === "hasOwnProperty") return kc } const c = Reflect.get(t, n, re(t) ? t : s); if ((ut(n) ? Jr.has(n) : Bc(n)) || (r || ce(t, "get", n), o)) return c; if (re(c)) { const l = i && Ds(n) ? c : c.value; return r && G(l) ? Bs(l) : l } return G(c) ? r ? Bs(c) : Hs(c) : c } } class Gr extends zr { constructor(t = !1) { super(!1, t) } set(t, n, s, r) { let o = t[n]; const i = $(t) && Ds(n); if (!this._isShallow) { const d = Ie(o); if (!de(s) && !Ie(s) && (o = H(o), s = H(s)), !i && re(o) && !re(s)) return d ? (process.env.NODE_ENV !== "production" && Ae(`Set operation on key "${String(n)}" failed: target is readonly.`, t[n]), !0) : (o.value = s, !0) } const c = i ? Number(n) < t.length : k(t, n), l = Reflect.set(t, n, s, re(t) ? t : r); return t === H(r) && (c ? ft(s, o) && Ke(t, "set", n, s, o) : Ke(t, "add", n, s)), l } deleteProperty(t, n) { const s = k(t, n), r = t[n], o = Reflect.deleteProperty(t, n); return o && s && Ke(t, "delete", n, void 0, r), o } has(t, n) { const s = Reflect.has(t, n); return (!ut(n) || !Jr.has(n)) && ce(t, "has", n), s } ownKeys(t) { return ce(t, "iterate", $(t) ? "length" : Nt), Reflect.ownKeys(t) } } class Xr extends zr { constructor(t = !1) { super(!0, t) } set(t, n) { return process.env.NODE_ENV !== "production" && Ae(`Set operation on key "${String(n)}" failed: target is readonly.`, t), !0 } deleteProperty(t, n) { return process.env.NODE_ENV !== "production" && Ae(`Delete operation on key "${String(n)}" failed: target is readonly.`, t), !0 } } const Kc = new Gr, Wc = new Xr, qc = new Gr(!0), Jc = new Xr(!0), Us = e => e, In = e => Reflect.getPrototypeOf(e); function zc(e, t, n) { return function (...s) { const r = this.__v_raw, o = H(r), i = _t(o), c = e === "entries" || e === Symbol.iterator && i, l = e === "keys" && i, d = r[e](...s), a = n ? Us : t ? Mt : Me; return !t && ce(o, "iterate", l ? Ms : Nt), ne(Object.create(d), { next() { const { value: f, done: g } = d.next(); return g ? { value: f, done: g } : { value: c ? [a(f[0]), a(f[1])] : a(f), done: g } } }) } } function Mn(e) { return function (...t) { if (process.env.NODE_ENV !== "production") { const n = t[0] ? `on key "${t[0]}" ` : ""; Ae(`${An(e)} operation ${n}failed: target is readonly.`, H(this)) } return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function Gc(e, t) { const n = { get(r) { const o = this.__v_raw, i = H(o), c = H(r); e || (ft(r, c) && ce(i, "get", r), ce(i, "get", c)); const { has: l } = In(i), d = t ? Us : e ? Mt : Me; if (l.call(i, r)) return d(o.get(r)); if (l.call(i, c)) return d(o.get(c)); o !== i && o.get(r) }, get size() { const r = this.__v_raw; return !e && ce(H(r), "iterate", Nt), r.size }, has(r) { const o = this.__v_raw, i = H(o), c = H(r); return e || (ft(r, c) && ce(i, "has", r), ce(i, "has", c)), r === c ? o.has(r) : o.has(r) || o.has(c) }, forEach(r, o) { const i = this, c = i.__v_raw, l = H(c), d = t ? Us : e ? Mt : Me; return !e && ce(l, "iterate", Nt), c.forEach((a, f) => r.call(o, d(a), d(f), i)) } }; return ne(n, e ? { add: Mn("add"), set: Mn("set"), delete: Mn("delete"), clear: Mn("clear") } : { add(r) { !t && !de(r) && !Ie(r) && (r = H(r)); const o = H(this); return In(o).has.call(o, r) || (o.add(r), Ke(o, "add", r, r)), this }, set(r, o) { !t && !de(o) && !Ie(o) && (o = H(o)); const i = H(this), { has: c, get: l } = In(i); let d = c.call(i, r); d ? process.env.NODE_ENV !== "production" && Yr(i, c, r) : (r = H(r), d = c.call(i, r)); const a = l.call(i, r); return i.set(r, o), d ? ft(o, a) && Ke(i, "set", r, o, a) : Ke(i, "add", r, o), this }, delete(r) { const o = H(this), { has: i, get: c } = In(o); let l = i.call(o, r); l ? process.env.NODE_ENV !== "production" && Yr(o, i, r) : (r = H(r), l = i.call(o, r)); const d = c ? c.call(o, r) : void 0, a = o.delete(r); return l && Ke(o, "delete", r, void 0, d), a }, clear() { const r = H(this), o = r.size !== 0, i = process.env.NODE_ENV !== "production" ? _t(r) ? new Map(r) : new Set(r) : void 0, c = r.clear(); return o && Ke(r, "clear", void 0, void 0, i), c } }), ["keys", "values", "entries", Symbol.iterator].forEach(r => { n[r] = zc(r, e, t) }), n } function jn(e, t) { const n = Gc(e, t); return (s, r, o) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get(k(n, r) && r in s ? n : s, r, o) } const Xc = { get: jn(!1, !1) }, Yc = { get: jn(!1, !0) }, Zc = { get: jn(!0, !1) }, Qc = { get: jn(!0, !0) }; function Yr(e, t, n) { const s = H(n); if (s !== n && t.call(e, s)) { const r = xs(e); Ae(`Reactive ${r} contains both the raw and reactive versions of the same object${r === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`) } } const Zr = new WeakMap, Qr = new WeakMap, eo = new WeakMap, to = new WeakMap; function el(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function tl(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : el(xs(e)) } function Hs(e) { return Ie(e) ? e : Ln(e, !1, Kc, Xc, Zr) } function nl(e) { return Ln(e, !1, qc, Yc, Qr) } function Bs(e) { return Ln(e, !0, Wc, Zc, eo) } function We(e) { return Ln(e, !0, Jc, Qc, to) } function Ln(e, t, n, s, r) { if (!G(e)) return process.env.NODE_ENV !== "production" && Ae(`value cannot be made ${t ? "readonly" : "reactive"}: ${String(e)}`), e; if (e.__v_raw && !(t && e.__v_isReactive)) return e; const o = tl(e); if (o === 0) return e; const i = r.get(e); if (i) return i; const c = new Proxy(e, o === 2 ? s : n); return r.set(e, c), c } function ht(e) { return Ie(e) ? ht(e.__v_raw) : !!(e && e.__v_isReactive) } function Ie(e) { return !!(e && e.__v_isReadonly) } function de(e) { return !!(e && e.__v_isShallow) } function Un(e) { return e ? !!e.__v_raw : !1 } function H(e) { const t = e && e.__v_raw; return t ? H(t) : e } function sl(e) { return !k(e, "__v_skip") && Object.isExtensible(e) && Pn(e, "__v_skip", !0), e } const Me = e => G(e) ? Hs(e) : e, Mt = e => G(e) ? Bs(e) : e; function re(e) { return e ? e.__v_isRef === !0 : !1 } function jt(e) { return rl(e, !1) } function rl(e, t) { return re(e) ? e : new ol(e, t) } class ol { constructor(t, n) { this.dep = new $s, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : H(t), this._value = n ? t : Me(t), this.__v_isShallow = n } get value() { return process.env.NODE_ENV !== "production" ? this.dep.track({ target: this, type: "get", key: "value" }) : this.dep.track(), this._value } set value(t) { const n = this._rawValue, s = this.__v_isShallow || de(t) || Ie(t); t = s ? t : H(t), ft(t, n) && (this._rawValue = t, this._value = s ? t : Me(t), process.env.NODE_ENV !== "production" ? this.dep.trigger({ target: this, type: "set", key: "value", newValue: t, oldValue: n }) : this.dep.trigger()) } } function il(e) { return re(e) ? e.value : e } const cl = { get: (e, t, n) => t === "__v_raw" ? e : il(Reflect.get(e, t, n)), set: (e, t, n, s) => { const r = e[t]; return re(r) && !re(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s) } }; function no(e) { return ht(e) ? e : new Proxy(e, cl) } class ll { constructor(t, n, s) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new $s(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = tn - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s } notify() { if (this.flags |= 16, !(this.flags & 8) && q !== this) return Lr(this, !0), !0; process.env.NODE_ENV } get value() { const t = process.env.NODE_ENV !== "production" ? this.dep.track({ target: this, type: "get", key: "value" }) : this.dep.track(); return Br(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter ? this.setter(t) : process.env.NODE_ENV !== "production" && Ae("Write operation failed: computed value is readonly") } } function al(e, t, n = !1) { let s, r; M(e) ? s = e : (s = e.get, r = e.set); const o = new ll(s, r, n); return process.env.NODE_ENV, o } const Hn = {}, Bn = new WeakMap; let Ot; function ul(e, t = !1, n = Ot) { if (n) { let s = Bn.get(n); s || Bn.set(n, s = []), s.push(e) } else process.env.NODE_ENV !== "production" && !t && Ae("onWatcherCleanup() was called when there was no active watcher to associate with.") } function fl(e, t, n = W) { const { immediate: s, deep: r, once: o, scheduler: i, augmentJob: c, call: l } = n, d = R => { (n.onWarn || Ae)("Invalid watch source: ", R, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.") }, a = R => r ? R : de(R) || r === !1 || r === 0 ? rt(R, 1) : rt(R); let f, g, O, m, y = !1, C = !1; if (re(e) ? (g = () => e.value, y = de(e)) : ht(e) ? (g = () => a(e), y = !0) : $(e) ? (C = !0, y = e.some(R => ht(R) || de(R)), g = () => e.map(R => { if (re(R)) return R.value; if (ht(R)) return a(R); if (M(R)) return l ? l(R, 2) : R(); process.env.NODE_ENV !== "production" && d(R) })) : M(e) ? t ? g = l ? () => l(e, 2) : e : g = () => { if (O) { Fe(); try { O() } finally { $e() } } const R = Ot; Ot = f; try { return l ? l(e, 3, [m]) : e(m) } finally { Ot = R } } : (g = ie, process.env.NODE_ENV !== "production" && d(e)), t && r) { const R = g, z = r === !0 ? 1 / 0 : r; g = () => rt(R(), z) } const P = Mc(), F = () => { f.stop(), P && P.active && ws(P.effects, f) }; if (o && t) { const R = t; t = (...z) => { R(...z), F() } } let V = C ? new Array(e.length).fill(Hn) : Hn; const J = R => { if (!(!(f.flags & 1) || !f.dirty && !R)) if (t) { const z = f.run(); if (r || y || (C ? z.some((Z, oe) => ft(Z, V[oe])) : ft(z, V))) { O && O(); const Z = Ot; Ot = f; try { const oe = [z, V === Hn ? void 0 : C && V[0] === Hn ? [] : V, m]; V = z, l ? l(t, 3, oe) : t(...oe) } finally { Ot = Z } } } else f.run() }; return c && c(J), f = new Mr(g), f.scheduler = i ? () => i(J, !1) : J, m = R => ul(R, !1, f), O = f.onStop = () => { const R = Bn.get(f); if (R) { if (l) l(R, 4); else for (const z of R) z(); Bn.delete(f) } }, process.env.NODE_ENV !== "production" && (f.onTrack = n.onTrack, f.onTrigger = n.onTrigger), t ? s ? J(!0) : V = f.run() : i ? i(J.bind(null, !0), !0) : f.run(), F.pause = f.pause.bind(f), F.resume = f.resume.bind(f), F.stop = F, F } function rt(e, t = 1 / 0, n) { if (t <= 0 || !G(e) || e.__v_skip || (n = n || new Map, (n.get(e) || 0) >= t)) return e; if (n.set(e, t), t--, re(e)) rt(e.value, t, n); else if ($(e)) for (let s = 0; s < e.length; s++)rt(e[s], t, n); else if (Rr(e) || _t(e)) e.forEach(s => { rt(s, t, n) }); else if (Ar(e)) { for (const s in e) rt(e[s], t, n); for (const s of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, s) && rt(e[s], t, n) } return e }/**
* @vue/runtime-core v3.5.27
* (c) 2026-chenyunliang and Vue contributors
* @license MIT
**/const wt = []; function kn(e) { wt.push(e) } function Kn() { wt.pop() } let ks = !1; function x(e, ...t) {
        if (ks) return; ks = !0, Fe(); const n = wt.length ? wt[wt.length - 1].component : null, s = n && n.appContext.config.warnHandler, r = dl(); if (s) Lt(s, n, 11, [e + t.map(o => { var i, c; return (c = (i = o.toString) == null ? void 0 : i.call(o)) != null ? c : JSON.stringify(o) }).join(""), n && n.proxy, r.map(({ vnode: o }) => `at <${yn(n, o.type)}>`).join(`
`), r]); else {
            const o = [`[Vue warn]: ${e}`, ...t]; r.length && o.push(`
`, ...pl(r)), console.warn(...o)
        } $e(), ks = !1
    } function dl() { let e = wt[wt.length - 1]; if (!e) return []; const t = []; for (; e;) { const n = t[0]; n && n.vnode === e ? n.recurseCount++ : t.push({ vnode: e, recurseCount: 0 }); const s = e.component && e.component.parent; e = s && s.vnode } return t } function pl(e) {
        const t = []; return e.forEach((n, s) => {
            t.push(...s === 0 ? [] : [`
`], ...hl(n))
        }), t
    } function hl({ vnode: e, recurseCount: t }) { const n = t > 0 ? `... (${t} recursive calls)` : "", s = e.component ? e.component.parent == null : !1, r = ` at <${yn(e.component, e.type, s)}`, o = ">" + n; return e.props ? [r, ...ml(e.props), o] : [r + o] } function ml(e) { const t = [], n = Object.keys(e); return n.slice(0, 3).forEach(s => { t.push(...so(s, e[s])) }), n.length > 3 && t.push(" ..."), t } function so(e, t, n) { return ee(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : re(t) ? (t = so(e, H(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : M(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = H(t), n ? t : [`${e}=`, t]) } const Ks = { sp: "serverPrefetch hook", bc: "beforeCreate hook", c: "created hook", bm: "beforeMount hook", m: "mounted hook", bu: "beforeUpdate hook", u: "updated", bum: "beforeUnmount hook", um: "unmounted hook", a: "activated hook", da: "deactivated hook", ec: "errorCaptured hook", rtc: "renderTracked hook", rtg: "renderTriggered hook", 0: "setup function", 1: "render function", 2: "watcher getter", 3: "watcher callback", 4: "watcher cleanup function", 5: "native event handler", 6: "component event handler", 7: "vnode hook", 8: "directive hook", 9: "transition hook", 10: "app errorHandler", 11: "app warnHandler", 12: "ref function", 13: "async component loader", 14: "scheduler flush", 15: "component update", 16: "app unmount cleanup function" }; function Lt(e, t, n, s) { try { return s ? e(...s) : e() } catch (r) { rn(r, t, n) } } function qe(e, t, n, s) { if (M(e)) { const r = Lt(e, t, n, s); return r && Ss(r) && r.catch(o => { rn(o, t, n) }), r } if ($(e)) { const r = []; for (let o = 0; o < e.length; o++)r.push(qe(e[o], t, n, s)); return r } else process.env.NODE_ENV !== "production" && x(`Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e}`) } function rn(e, t, n, s = !0) { const r = t ? t.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: i } = t && t.appContext.config || W; if (t) { let c = t.parent; const l = t.proxy, d = process.env.NODE_ENV !== "production" ? Ks[n] : `https://vuejs.org/error-reference/#runtime-${n}`; for (; c;) { const a = c.ec; if (a) { for (let f = 0; f < a.length; f++)if (a[f](e, l, d) === !1) return } c = c.parent } if (o) { Fe(), Lt(o, null, 10, [e, l, d]), $e(); return } } gl(e, n, r, s, i) } function gl(e, t, n, s = !0, r = !1) { if (process.env.NODE_ENV !== "production") { const o = Ks[t]; if (n && kn(n), x(`Unhandled error${o ? ` during execution of ${o}` : ""}`), n && Kn(), s) throw e; console.error(e) } else { if (r) throw e; console.error(e) } } const pe = []; let Je = -1; const Ut = []; let mt = null, Ht = 0; const ro = Promise.resolve(); let Wn = null; const El = 100; function oo(e) { const t = Wn || ro; return e ? t.then(this ? e.bind(this) : e) : t } function bl(e) { let t = Je + 1, n = pe.length; for (; t < n;) { const s = t + n >>> 1, r = pe[s], o = on(r); o < e || o === e && r.flags & 2 ? t = s + 1 : n = s } return t } function qn(e) { if (!(e.flags & 1)) { const t = on(e), n = pe[pe.length - 1]; !n || !(e.flags & 2) && t >= on(n) ? pe.push(e) : pe.splice(bl(t), 0, e), e.flags |= 1, io() } } function io() { Wn || (Wn = ro.then(uo)) } function co(e) { $(e) ? Ut.push(...e) : mt && e.id === -1 ? mt.splice(Ht + 1, 0, e) : e.flags & 1 || (Ut.push(e), e.flags |= 1), io() } function lo(e, t, n = Je + 1) { for (process.env.NODE_ENV !== "production" && (t = t || new Map); n < pe.length; n++) { const s = pe[n]; if (s && s.flags & 2) { if (e && s.id !== e.uid || process.env.NODE_ENV !== "production" && Ws(t, s)) continue; pe.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2) } } } function ao(e) { if (Ut.length) { const t = [...new Set(Ut)].sort((n, s) => on(n) - on(s)); if (Ut.length = 0, mt) { mt.push(...t); return } for (mt = t, process.env.NODE_ENV !== "production" && (e = e || new Map), Ht = 0; Ht < mt.length; Ht++) { const n = mt[Ht]; process.env.NODE_ENV !== "production" && Ws(e, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2) } mt = null, Ht = 0 } } const on = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function uo(e) { process.env.NODE_ENV !== "production" && (e = e || new Map); const t = process.env.NODE_ENV !== "production" ? n => Ws(e, n) : ie; try { for (Je = 0; Je < pe.length; Je++) { const n = pe[Je]; if (n && !(n.flags & 8)) { if (process.env.NODE_ENV !== "production" && t(n)) continue; n.flags & 4 && (n.flags &= -2), Lt(n, n.i, n.i ? 15 : 14), n.flags & 4 || (n.flags &= -2) } } } finally { for (; Je < pe.length; Je++) { const n = pe[Je]; n && (n.flags &= -2) } Je = -1, pe.length = 0, ao(e), Wn = null, (pe.length || Ut.length) && uo(e) } } function Ws(e, t) { const n = e.get(t) || 0; if (n > El) { const s = t.i, r = s && ui(s.type); return rn(`Maximum recursive updates exceeded${r ? ` in component <${r}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`, null, 10), !0 } return e.set(t, n + 1), !1 } let je = !1; const Jn = new Map; process.env.NODE_ENV !== "production" && (Yt().__VUE_HMR_RUNTIME__ = { createRecord: qs(fo), rerender: qs(vl), reload: qs(Nl) }); const St = new Map; function yl(e) { const t = e.type.__hmrId; let n = St.get(t); n || (fo(t, e.type), n = St.get(t)), n.instances.add(e) } function _l(e) { St.get(e.type.__hmrId).instances.delete(e) } function fo(e, t) { return St.has(e) ? !1 : (St.set(e, { initialDef: zn(t), instances: new Set }), !0) } function zn(e) { return fi(e) ? e.__vccOpts : e } function vl(e, t) { const n = St.get(e); n && (n.initialDef.render = t, [...n.instances].forEach(s => { t && (s.render = t, zn(s.type).render = t), s.renderCache = [], je = !0, s.job.flags & 8 || s.update(), je = !1 })) } function Nl(e, t) { const n = St.get(e); if (!n) return; t = zn(t), po(n.initialDef, t); const s = [...n.instances]; for (let r = 0; r < s.length; r++) { const o = s[r], i = zn(o.type); let c = Jn.get(i); c || (i !== n.initialDef && po(i, t), Jn.set(i, c = new Set)), c.add(o), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (c.add(o), o.ceReload(t.styles), c.delete(o)) : o.parent ? qn(() => { o.job.flags & 8 || (je = !0, o.parent.update(), je = !1, c.delete(o)) }) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required."), o.root.ce && o !== o.root && o.root.ce._removeChildStyle(i) } co(() => { Jn.clear() }) } function po(e, t) { ne(e, t); for (const n in e) n !== "__file" && !(n in t) && delete e[n] } function qs(e) { return (t, n) => { try { return e(t, n) } catch (s) { console.error(s), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.") } } } let Le, cn = [], Js = !1; function ln(e, ...t) { Le ? Le.emit(e, ...t) : Js || cn.push({ event: e, args: t }) } function zs(e, t) { var n, s; Le = e, Le ? (Le.enabled = !0, cn.forEach(({ event: r, args: o }) => Le.emit(r, ...o)), cn = []) : typeof window < "u" && window.HTMLElement && !((s = (n = window.navigator) == null ? void 0 : n.userAgent) != null && s.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(o => { zs(o, t) }), setTimeout(() => { Le || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Js = !0, cn = []) }, 3e3)) : (Js = !0, cn = []) } function Ol(e, t) { ln("app:init", e, t, { Fragment: Ce, Text: pn, Comment: we, Static: os }) } function wl(e) { ln("app:unmount", e) } const Sl = Gs("component:added"), ho = Gs("component:updated"), xl = Gs("component:removed"), Dl = e => { Le && typeof Le.cleanupBuffer == "function" && !Le.cleanupBuffer(e) && xl(e) }; function Gs(e) { return t => { ln(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t) } } const Cl = mo("perf:start"), Tl = mo("perf:end"); function mo(e) { return (t, n, s) => { ln(e, t.appContext.app, t.uid, t, n, s) } } function Rl(e, t, n) { ln("component:emit", e.appContext.app, e, t, n) } let he = null, go = null; function Gn(e) { const t = he; return he = e, go = e && e.type.__scopeId || null, t } function Vl(e, t = he, n) { if (!t || e._n) return e; const s = (...r) => { s._d && Qo(-1); const o = Gn(t); let i; try { i = e(...r) } finally { Gn(o), s._d && Qo(1) } return process.env.NODE_ENV !== "production" && ho(t), i }; return s._n = !0, s._c = !0, s._d = !0, s } function Eo(e) { Nc(e) && x("Do not use built-in directive ids as custom directive id: " + e) } function Al(e, t) { if (he === null) return process.env.NODE_ENV !== "production" && x("withDirectives can only be used inside render functions."), e; const n = us(he), s = e.dirs || (e.dirs = []); for (let r = 0; r < t.length; r++) { let [o, i, c, l = W] = t[r]; o && (M(o) && (o = { mounted: o, updated: o }), o.deep && rt(i), s.push({ dir: o, instance: n, value: i, oldValue: void 0, arg: c, modifiers: l })) } return e } function xt(e, t, n, s) { const r = e.dirs, o = t && t.dirs; for (let i = 0; i < r.length; i++) { const c = r[i]; o && (c.oldValue = o[i].value); let l = c.dir[s]; l && (Fe(), qe(l, n, 8, [e.el, c, e, t]), $e()) } } function Pl(e, t) { if (process.env.NODE_ENV !== "production" && (!le || le.isMounted) && x("provide() can only be used inside setup()."), le) { let n = le.provides; const s = le.parent && le.parent.provides; s === n && (n = le.provides = Object.create(s)), n[e] = t } } function Xn(e, t, n = !1) { const s = ri(); if (s || Bt) { let r = Bt ? Bt._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0; if (r && e in r) return r[e]; if (arguments.length > 1) return n && M(t) ? t.call(s && s.proxy) : t; process.env.NODE_ENV !== "production" && x(`injection "${String(e)}" not found.`) } else process.env.NODE_ENV !== "production" && x("inject() can only be used inside setup() or functional components.") } const Fl = Symbol.for("v-scx"), $l = () => { { const e = Xn(Fl); return e || process.env.NODE_ENV !== "production" && x("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), e } }; function Yn(e, t, n) { return process.env.NODE_ENV !== "production" && !M(t) && x("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), bo(e, t, n) } function bo(e, t, n = W) { const { immediate: s, deep: r, flush: o, once: i } = n; process.env.NODE_ENV !== "production" && !t && (s !== void 0 && x('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), r !== void 0 && x('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'), i !== void 0 && x('watch() "once" option is only respected when using the watch(source, callback, options?) signature.')); const c = ne({}, n); process.env.NODE_ENV !== "production" && (c.onWarn = x); const l = t && s || !t && o !== "post"; let d; if (bn) { if (o === "sync") { const O = $l(); d = O.__watcherHandles || (O.__watcherHandles = []) } else if (!l) { const O = () => { }; return O.stop = ie, O.resume = ie, O.pause = ie, O } } const a = le; c.call = (O, m, y) => qe(O, a, m, y); let f = !1; o === "post" ? c.scheduler = O => { Oe(O, a && a.suspense) } : o !== "sync" && (f = !0, c.scheduler = (O, m) => { m ? O() : qn(O) }), c.augmentJob = O => { t && (O.flags |= 4), f && (O.flags |= 2, a && (O.id = a.uid, O.i = a)) }; const g = fl(e, t, c); return bn && (d ? d.push(g) : l && g()), g } function Il(e, t, n) { const s = this.proxy, r = ee(e) ? e.includes(".") ? yo(s, e) : () => s[e] : e.bind(s, s); let o; M(t) ? o = t : (o = t.handler, n = t); const i = En(this), c = bo(r, o.bind(s), n); return i(), c } function yo(e, t) { const n = t.split("."); return () => { let s = e; for (let r = 0; r < n.length && s; r++)s = s[n[r]]; return s } } const Ml = Symbol("_vte"), jl = e => e.__isTeleport, Ll = Symbol("_leaveCb"); function Xs(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Xs(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function Ul(e, t) { return M(e) ? ne({ name: e.name }, t, { setup: e }) : e } function _o(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } const vo = new WeakSet, Zn = new WeakMap; function an(e, t, n, s, r = !1) { if ($(e)) { e.forEach((y, C) => an(y, t && ($(t) ? t[C] : t), n, s, r)); return } if (un(s) && !r) { s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && an(e, t, n, s.component.subTree); return } const o = s.shapeFlag & 4 ? us(s.component) : s.el, i = r ? null : o, { i: c, r: l } = e; if (process.env.NODE_ENV !== "production" && !c) { x("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."); return } const d = t && t.r, a = c.refs === W ? c.refs = {} : c.refs, f = c.setupState, g = H(f), O = f === W ? Tr : y => process.env.NODE_ENV !== "production" && (k(g, y) && !re(g[y]) && x(`Template ref "${y}" used on a non-ref value. It will not work in the production build.`), vo.has(g[y])) ? !1 : k(g, y), m = y => process.env.NODE_ENV === "production" || !vo.has(y); if (d != null && d !== l) { if (No(t), ee(d)) a[d] = null, O(d) && (f[d] = null); else if (re(d)) { m(d) && (d.value = null); const y = t; y.k && (a[y.k] = null) } } if (M(l)) Lt(l, c, 12, [i, a]); else { const y = ee(l), C = re(l); if (y || C) { const P = () => { if (e.f) { const F = y ? O(l) ? f[l] : a[l] : m(l) || !e.k ? l.value : a[e.k]; if (r) $(F) && ws(F, o); else if ($(F)) F.includes(o) || F.push(o); else if (y) a[l] = [o], O(l) && (f[l] = a[l]); else { const V = [o]; m(l) && (l.value = V), e.k && (a[e.k] = V) } } else y ? (a[l] = i, O(l) && (f[l] = i)) : C ? (m(l) && (l.value = i), e.k && (a[e.k] = i)) : process.env.NODE_ENV !== "production" && x("Invalid template ref type:", l, `(${typeof l})`) }; if (i) { const F = () => { P(), Zn.delete(e) }; F.id = -1, Zn.set(e, F), Oe(F, n) } else No(e), P() } else process.env.NODE_ENV !== "production" && x("Invalid template ref type:", l, `(${typeof l})`) } } function No(e) { const t = Zn.get(e); t && (t.flags |= 8, Zn.delete(e)) } Yt().requestIdleCallback, Yt().cancelIdleCallback; const un = e => !!e.type.__asyncLoader, Ys = e => e.type.__isKeepAlive; function Hl(e, t) { Oo(e, "a", t) } function Bl(e, t) { Oo(e, "da", t) } function Oo(e, t, n = le) { const s = e.__wdc || (e.__wdc = () => { let r = n; for (; r;) { if (r.isDeactivated) return; r = r.parent } return e() }); if (Qn(t, s, n), n) { let r = n.parent; for (; r && r.parent;)Ys(r.parent.vnode) && kl(s, t, n, r), r = r.parent } } function kl(e, t, n, s) { const r = Qn(t, e, s, !0); wo(() => { ws(s[t], r) }, n) } function Qn(e, t, n = le, s = !1) { if (n) { const r = n[e] || (n[e] = []), o = t.__weh || (t.__weh = (...i) => { Fe(); const c = En(n), l = qe(t, n, e, i); return c(), $e(), l }); return s ? r.unshift(o) : r.push(o), o } else if (process.env.NODE_ENV !== "production") { const r = vt(Ks[e].replace(/ hook$/, "")); x(`${r} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`) } } const ot = e => (t, n = le) => { (!bn || e === "sp") && Qn(e, (...s) => t(...s), n) }, Kl = ot("bm"), Wl = ot("m"), ql = ot("bu"), Jl = ot("u"), zl = ot("bum"), wo = ot("um"), Gl = ot("sp"), Xl = ot("rtg"), Yl = ot("rtc"); function Zl(e, t = le) { Qn("ec", e, t) } const Ql = Symbol.for("v-ndc"); function ea(e, t, n, s) { let r; const o = n, i = $(e); if (i || ee(e)) { const c = i && ht(e); let l = !1, d = !1; c && (l = !de(e), d = Ie(e), e = $n(e)), r = new Array(e.length); for (let a = 0, f = e.length; a < f; a++)r[a] = t(l ? d ? Mt(Me(e[a])) : Me(e[a]) : e[a], a, void 0, o) } else if (typeof e == "number") { process.env.NODE_ENV !== "production" && !Number.isInteger(e) && x(`The v-for range expect an integer value but got ${e}.`), r = new Array(e); for (let c = 0; c < e; c++)r[c] = t(c + 1, c, void 0, o) } else if (G(e)) if (e[Symbol.iterator]) r = Array.from(e, (c, l) => t(c, l, void 0, o)); else { const c = Object.keys(e); r = new Array(c.length); for (let l = 0, d = c.length; l < d; l++) { const a = c[l]; r[l] = t(e[a], a, l, o) } } else r = []; return r } const Zs = e => e ? ii(e) ? us(e) : Zs(e.parent) : null, Dt = ne(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => process.env.NODE_ENV !== "production" ? We(e.props) : e.props, $attrs: e => process.env.NODE_ENV !== "production" ? We(e.attrs) : e.attrs, $slots: e => process.env.NODE_ENV !== "production" ? We(e.slots) : e.slots, $refs: e => process.env.NODE_ENV !== "production" ? We(e.refs) : e.refs, $parent: e => Zs(e.parent), $root: e => Zs(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => To(e), $forceUpdate: e => e.f || (e.f = () => { qn(e.update) }), $nextTick: e => e.n || (e.n = oo.bind(e.proxy)), $watch: e => Il.bind(e) }), Qs = e => e === "_" || e === "$", er = (e, t) => e !== W && !e.__isScriptSetup && k(e, t), So = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: s, data: r, props: o, accessCache: i, type: c, appContext: l } = e; if (process.env.NODE_ENV !== "production" && t === "__isVue") return !0; if (t[0] !== "$") { const g = i[t]; if (g !== void 0) switch (g) { case 1: return s[t]; case 2: return r[t]; case 4: return n[t]; case 3: return o[t] } else { if (er(s, t)) return i[t] = 1, s[t]; if (r !== W && k(r, t)) return i[t] = 2, r[t]; if (k(o, t)) return i[t] = 3, o[t]; if (n !== W && k(n, t)) return i[t] = 4, n[t]; tr && (i[t] = 0) } } const d = Dt[t]; let a, f; if (d) return t === "$attrs" ? (ce(e.attrs, "get", ""), process.env.NODE_ENV !== "production" && ns()) : process.env.NODE_ENV !== "production" && t === "$slots" && ce(e, "get", t), d(e); if ((a = c.__cssModules) && (a = a[t])) return a; if (n !== W && k(n, t)) return i[t] = 4, n[t]; if (f = l.config.globalProperties, k(f, t)) return f[t]; process.env.NODE_ENV !== "production" && he && (!ee(t) || t.indexOf("__v") !== 0) && (r !== W && Qs(t[0]) && k(r, t) ? x(`Property ${JSON.stringify(t)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : e === he && x(`Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`)) }, set({ _: e }, t, n) { const { data: s, setupState: r, ctx: o } = e; return er(r, t) ? (r[t] = n, !0) : process.env.NODE_ENV !== "production" && r.__isScriptSetup && k(r, t) ? (x(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : s !== W && k(s, t) ? (s[t] = n, !0) : k(e.props, t) ? (process.env.NODE_ENV !== "production" && x(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? (process.env.NODE_ENV !== "production" && x(`Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`), !1) : (process.env.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(o, t, { enumerable: !0, configurable: !0, value: n }) : o[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: r, props: o, type: i } }, c) { let l; return !!(n[c] || e !== W && c[0] !== "$" && k(e, c) || er(t, c) || k(o, c) || k(s, c) || k(Dt, c) || k(r.config.globalProperties, c) || (l = i.__cssModules) && l[c]) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : k(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; process.env.NODE_ENV !== "production" && (So.ownKeys = e => (x("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(e))); function ta(e) { const t = {}; return Object.defineProperty(t, "_", { configurable: !0, enumerable: !1, get: () => e }), Object.keys(Dt).forEach(n => { Object.defineProperty(t, n, { configurable: !0, enumerable: !1, get: () => Dt[n](e), set: ie }) }), t } function na(e) { const { ctx: t, propsOptions: [n] } = e; n && Object.keys(n).forEach(s => { Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => e.props[s], set: ie }) }) } function sa(e) { const { ctx: t, setupState: n } = e; Object.keys(H(n)).forEach(s => { if (!n.__isScriptSetup) { if (Qs(s[0])) { x(`setup() return property ${JSON.stringify(s)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`); return } Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => n[s], set: ie }) } }) } function xo(e) { return $(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } function ra() { const e = Object.create(null); return (t, n) => { e[n] ? x(`${t} property "${n}" is already defined in ${e[n]}.`) : e[n] = t } } let tr = !0; function oa(e) { const t = To(e), n = e.proxy, s = e.ctx; tr = !1, t.beforeCreate && Do(t.beforeCreate, e, "bc"); const { data: r, computed: o, methods: i, watch: c, provide: l, inject: d, created: a, beforeMount: f, mounted: g, beforeUpdate: O, updated: m, activated: y, deactivated: C, beforeDestroy: P, beforeUnmount: F, destroyed: V, unmounted: J, render: R, renderTracked: z, renderTriggered: Z, errorCaptured: oe, serverPrefetch: ae, expose: Te, inheritAttrs: Be, components: fe, directives: Xe, filters: Ye } = t, ke = process.env.NODE_ENV !== "production" ? ra() : null; if (process.env.NODE_ENV !== "production") { const [B] = e.propsOptions; if (B) for (const L in B) ke("Props", L) } if (d && ia(d, s, ke), i) for (const B in i) { const L = i[B]; M(L) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(s, B, { value: L.bind(n), configurable: !0, enumerable: !0, writable: !0 }) : s[B] = L.bind(n), process.env.NODE_ENV !== "production" && ke("Methods", B)) : process.env.NODE_ENV !== "production" && x(`Method "${B}" has type "${typeof L}" in the component definition. Did you reference the function correctly?`) } if (r) { process.env.NODE_ENV !== "production" && !M(r) && x("The data option must be a function. Plain object usage is no longer supported."); const B = r.call(n, n); if (process.env.NODE_ENV !== "production" && Ss(B) && x("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !G(B)) process.env.NODE_ENV !== "production" && x("data() should return an object."); else if (e.data = Hs(B), process.env.NODE_ENV !== "production") for (const L in B) ke("Data", L), Qs(L[0]) || Object.defineProperty(s, L, { configurable: !0, enumerable: !0, get: () => B[L], set: ie }) } if (tr = !0, o) for (const B in o) { const L = o[B], xe = M(L) ? L.bind(n, n) : M(L.get) ? L.get.bind(n, n) : ie; process.env.NODE_ENV !== "production" && xe === ie && x(`Computed property "${B}" has no getter.`); const Sn = !M(L) && M(L.set) ? L.set.bind(n) : process.env.NODE_ENV !== "production" ? () => { x(`Write operation failed: computed property "${B}" is readonly.`) } : ie, _e = Rt({ get: xe, set: Sn }); Object.defineProperty(s, B, { enumerable: !0, configurable: !0, get: () => _e.value, set: De => _e.value = De }), process.env.NODE_ENV !== "production" && ke("Computed", B) } if (c) for (const B in c) Co(c[B], s, n, B); if (l) { const B = M(l) ? l.call(n) : l; Reflect.ownKeys(B).forEach(L => { Pl(L, B[L]) }) } a && Do(a, e, "c"); function Q(B, L) { $(L) ? L.forEach(xe => B(xe.bind(n))) : L && B(L.bind(n)) } if (Q(Kl, f), Q(Wl, g), Q(ql, O), Q(Jl, m), Q(Hl, y), Q(Bl, C), Q(Zl, oe), Q(Yl, z), Q(Xl, Z), Q(zl, F), Q(wo, J), Q(Gl, ae), $(Te)) if (Te.length) { const B = e.exposed || (e.exposed = {}); Te.forEach(L => { Object.defineProperty(B, L, { get: () => n[L], set: xe => n[L] = xe, enumerable: !0 }) }) } else e.exposed || (e.exposed = {}); R && e.render === ie && (e.render = R), Be != null && (e.inheritAttrs = Be), fe && (e.components = fe), Xe && (e.directives = Xe), ae && _o(e) } function ia(e, t, n = ie) { $(e) && (e = nr(e)); for (const s in e) { const r = e[s]; let o; G(r) ? "default" in r ? o = Xn(r.from || s, r.default, !0) : o = Xn(r.from || s) : o = Xn(r), re(o) ? Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => o.value, set: i => o.value = i }) : t[s] = o, process.env.NODE_ENV !== "production" && n("Inject", s) } } function Do(e, t, n) { qe($(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, n) } function Co(e, t, n, s) { let r = s.includes(".") ? yo(n, s) : () => n[s]; if (ee(e)) { const o = t[e]; M(o) ? Yn(r, o) : process.env.NODE_ENV !== "production" && x(`Invalid watch handler specified by key "${e}"`, o) } else if (M(e)) Yn(r, e.bind(n)); else if (G(e)) if ($(e)) e.forEach(o => Co(o, t, n, s)); else { const o = M(e.handler) ? e.handler.bind(n) : t[e.handler]; M(o) ? Yn(r, o, e) : process.env.NODE_ENV !== "production" && x(`Invalid watch handler specified by key "${e.handler}"`, o) } else process.env.NODE_ENV !== "production" && x(`Invalid watch option: "${s}"`, e) } function To(e) { const t = e.type, { mixins: n, extends: s } = t, { mixins: r, optionsCache: o, config: { optionMergeStrategies: i } } = e.appContext, c = o.get(t); let l; return c ? l = c : !r.length && !n && !s ? l = t : (l = {}, r.length && r.forEach(d => es(l, d, i, !0)), es(l, t, i)), G(t) && o.set(t, l), l } function es(e, t, n, s = !1) { const { mixins: r, extends: o } = t; o && es(e, o, n, !0), r && r.forEach(i => es(e, i, n, !0)); for (const i in t) if (s && i === "expose") process.env.NODE_ENV !== "production" && x('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'); else { const c = ca[i] || n && n[i]; e[i] = c ? c(e[i], t[i]) : t[i] } return e } const ca = { data: Ro, props: Vo, emits: Vo, methods: fn, computed: fn, beforeCreate: me, created: me, beforeMount: me, mounted: me, beforeUpdate: me, updated: me, beforeDestroy: me, beforeUnmount: me, destroyed: me, unmounted: me, activated: me, deactivated: me, errorCaptured: me, serverPrefetch: me, components: fn, directives: fn, watch: aa, provide: Ro, inject: la }; function Ro(e, t) { return t ? e ? function () { return ne(M(e) ? e.call(this, this) : e, M(t) ? t.call(this, this) : t) } : t : e } function la(e, t) { return fn(nr(e), nr(t)) } function nr(e) { if ($(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function me(e, t) { return e ? [...new Set([].concat(e, t))] : t } function fn(e, t) { return e ? ne(Object.create(null), e, t) : t } function Vo(e, t) { return e ? $(e) && $(t) ? [...new Set([...e, ...t])] : ne(Object.create(null), xo(e), xo(t ?? {})) : t } function aa(e, t) { if (!e) return t; if (!t) return e; const n = ne(Object.create(null), e); for (const s in t) n[s] = me(e[s], t[s]); return n } function Ao() { return { app: null, config: { isNativeTag: Tr, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let ua = 0; function fa(e, t) { return function (s, r = null) { M(s) || (s = ne({}, s)), r != null && !G(r) && (process.env.NODE_ENV !== "production" && x("root props passed to app.mount() must be an object."), r = null); const o = Ao(), i = new WeakSet, c = []; let l = !1; const d = o.app = { _uid: ua++, _component: s, _props: r, _container: null, _context: o, _instance: null, version: di, get config() { return o.config }, set config(a) { process.env.NODE_ENV !== "production" && x("app.config cannot be replaced. Modify individual options instead.") }, use(a, ...f) { return i.has(a) ? process.env.NODE_ENV !== "production" && x("Plugin has already been applied to target app.") : a && M(a.install) ? (i.add(a), a.install(d, ...f)) : M(a) ? (i.add(a), a(d, ...f)) : process.env.NODE_ENV !== "production" && x('A plugin must either be a function or an object with an "install" function.'), d }, mixin(a) { return o.mixins.includes(a) ? process.env.NODE_ENV !== "production" && x("Mixin has already been applied to target app" + (a.name ? `: ${a.name}` : "")) : o.mixins.push(a), d }, component(a, f) { return process.env.NODE_ENV !== "production" && dr(a, o.config), f ? (process.env.NODE_ENV !== "production" && o.components[a] && x(`Component "${a}" has already been registered in target app.`), o.components[a] = f, d) : o.components[a] }, directive(a, f) { return process.env.NODE_ENV !== "production" && Eo(a), f ? (process.env.NODE_ENV !== "production" && o.directives[a] && x(`Directive "${a}" has already been registered in target app.`), o.directives[a] = f, d) : o.directives[a] }, mount(a, f, g) { if (l) process.env.NODE_ENV !== "production" && x("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"); else { process.env.NODE_ENV !== "production" && a.__vue_app__ && x("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."); const O = d._ceVNode || ct(s, r); return O.appContext = o, g === !0 ? g = "svg" : g === !1 && (g = void 0), process.env.NODE_ENV !== "production" && (o.reload = () => { const m = Et(O); m.el = null, e(m, a, g) }), e(O, a, g), l = !0, d._container = a, a.__vue_app__ = d, process.env.NODE_ENV !== "production" && (d._instance = O.component, Ol(d, di)), us(O.component) } }, onUnmount(a) { process.env.NODE_ENV !== "production" && typeof a != "function" && x(`Expected function as first argument to app.onUnmount(), but got ${typeof a}`), c.push(a) }, unmount() { l ? (qe(c, d._instance, 16), e(null, d._container), process.env.NODE_ENV !== "production" && (d._instance = null, wl(d)), delete d._container.__vue_app__) : process.env.NODE_ENV !== "production" && x("Cannot unmount an app that is not mounted.") }, provide(a, f) { return process.env.NODE_ENV !== "production" && a in o.provides && (k(o.provides, a) ? x(`App already provides property with key "${String(a)}". It will be overwritten with the new value.`) : x(`App already provides property with key "${String(a)}" inherited from its parent element. It will be overwritten with the new value.`)), o.provides[a] = f, d }, runWithContext(a) { const f = Bt; Bt = d; try { return a() } finally { Bt = f } } }; return d } } let Bt = null; const da = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Ve(t)}Modifiers`] || e[`${nt(t)}Modifiers`]; function pa(e, t, ...n) { if (e.isUnmounted) return; const s = e.vnode.props || W; if (process.env.NODE_ENV !== "production") { const { emitsOptions: a, propsOptions: [f] } = e; if (a) if (!(t in a)) (!f || !(vt(Ve(t)) in f)) && x(`Component emitted event "${t}" but it is neither declared in the emits option nor as an "${vt(Ve(t))}" prop.`); else { const g = a[t]; M(g) && (g(...n) || x(`Invalid event arguments: event validation failed for event "${t}".`)) } } let r = n; const o = t.startsWith("update:"), i = o && da(s, t.slice(7)); if (i && (i.trim && (r = n.map(a => ee(a) ? a.trim() : a)), i.number && (r = n.map(Cs))), process.env.NODE_ENV !== "production" && Rl(e, t, r), process.env.NODE_ENV !== "production") { const a = t.toLowerCase(); a !== t && s[vt(a)] && x(`Event "${a}" is emitted in component ${yn(e, e.type)} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${nt(t)}" instead of "${t}".`) } let c, l = s[c = vt(t)] || s[c = vt(Ve(t))]; !l && o && (l = s[c = vt(nt(t))]), l && qe(l, e, 6, r); const d = s[c + "Once"]; if (d) { if (!e.emitted) e.emitted = {}; else if (e.emitted[c]) return; e.emitted[c] = !0, qe(d, e, 6, r) } } const ha = new WeakMap; function Po(e, t, n = !1) { const s = n ? ha : t.emitsCache, r = s.get(e); if (r !== void 0) return r; const o = e.emits; let i = {}, c = !1; if (!M(e)) { const l = d => { const a = Po(d, t, !0); a && (c = !0, ne(i, a)) }; !n && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l) } return !o && !c ? (G(e) && s.set(e, null), null) : ($(o) ? o.forEach(l => i[l] = null) : ne(i, o), G(e) && s.set(e, i), i) } function ts(e, t) { return !e || !Gt(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), k(e, t[0].toLowerCase() + t.slice(1)) || k(e, nt(t)) || k(e, t)) } let sr = !1; function ns() { sr = !0 } function Fo(e) { const { type: t, vnode: n, proxy: s, withProxy: r, propsOptions: [o], slots: i, attrs: c, emit: l, render: d, renderCache: a, props: f, data: g, setupState: O, ctx: m, inheritAttrs: y } = e, C = Gn(e); let P, F; process.env.NODE_ENV !== "production" && (sr = !1); try { if (n.shapeFlag & 4) { const R = r || s, z = process.env.NODE_ENV !== "production" && O.__isScriptSetup ? new Proxy(R, { get(Z, oe, ae) { return x(`Property '${String(oe)}' was accessed via 'this'. Avoid using 'this' in templates.`), Reflect.get(Z, oe, ae) } }) : R; P = Ue(d.call(z, R, a, process.env.NODE_ENV !== "production" ? We(f) : f, O, g, m)), F = c } else { const R = t; process.env.NODE_ENV !== "production" && c === f && ns(), P = Ue(R.length > 1 ? R(process.env.NODE_ENV !== "production" ? We(f) : f, process.env.NODE_ENV !== "production" ? { get attrs() { return ns(), We(c) }, slots: i, emit: l } : { attrs: c, slots: i, emit: l }) : R(process.env.NODE_ENV !== "production" ? We(f) : f, null)), F = t.props ? c : ma(c) } } catch (R) { hn.length = 0, rn(R, e, 1), P = ct(we) } let V = P, J; if (process.env.NODE_ENV !== "production" && P.patchFlag > 0 && P.patchFlag & 2048 && ([V, J] = $o(P)), F && y !== !1) { const R = Object.keys(F), { shapeFlag: z } = V; if (R.length) { if (z & 7) o && R.some(Tn) && (F = ga(F, o)), V = Et(V, F, !1, !0); else if (process.env.NODE_ENV !== "production" && !sr && V.type !== we) { const Z = Object.keys(c), oe = [], ae = []; for (let Te = 0, Be = Z.length; Te < Be; Te++) { const fe = Z[Te]; Gt(fe) ? Tn(fe) || oe.push(fe[2].toLowerCase() + fe.slice(3)) : ae.push(fe) } ae.length && x(`Extraneous non-props attributes (${ae.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`), oe.length && x(`Extraneous non-emits event listeners (${oe.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`) } } } return n.dirs && (process.env.NODE_ENV !== "production" && !Io(V) && x("Runtime directive used on component with non-element root node. The directives will not function as intended."), V = Et(V, null, !1, !0), V.dirs = V.dirs ? V.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !Io(V) && x("Component inside <Transition> renders non-element root node that cannot be animated."), Xs(V, n.transition)), process.env.NODE_ENV !== "production" && J ? J(V) : P = V, Gn(C), P } const $o = e => { const t = e.children, n = e.dynamicChildren, s = rr(t, !1); if (s) { if (process.env.NODE_ENV !== "production" && s.patchFlag > 0 && s.patchFlag & 2048) return $o(s) } else return [e, void 0]; const r = t.indexOf(s), o = n ? n.indexOf(s) : -1, i = c => { t[r] = c, n && (o > -1 ? n[o] = c : c.patchFlag > 0 && (e.dynamicChildren = [...n, c])) }; return [Ue(s), i] }; function rr(e, t = !0) { let n; for (let s = 0; s < e.length; s++) { const r = e[s]; if (is(r)) { if (r.type !== we || r.children === "v-if") { if (n) return; if (n = r, process.env.NODE_ENV !== "production" && t && n.patchFlag > 0 && n.patchFlag & 2048) return rr(n.children) } } else return } return n } const ma = e => { let t; for (const n in e) (n === "class" || n === "style" || Gt(n)) && ((t || (t = {}))[n] = e[n]); return t }, ga = (e, t) => { const n = {}; for (const s in e) (!Tn(s) || !(s.slice(9) in t)) && (n[s] = e[s]); return n }, Io = e => e.shapeFlag & 7 || e.type === we; function Ea(e, t, n) { const { props: s, children: r, component: o } = e, { props: i, children: c, patchFlag: l } = t, d = o.emitsOptions; if (process.env.NODE_ENV !== "production" && (r || c) && je || t.dirs || t.transition) return !0; if (n && l >= 0) { if (l & 1024) return !0; if (l & 16) return s ? Mo(s, i, d) : !!i; if (l & 8) { const a = t.dynamicProps; for (let f = 0; f < a.length; f++) { const g = a[f]; if (i[g] !== s[g] && !ts(d, g)) return !0 } } } else return (r || c) && (!c || !c.$stable) ? !0 : s === i ? !1 : s ? i ? Mo(s, i, d) : !0 : !!i; return !1 } function Mo(e, t, n) { const s = Object.keys(t); if (s.length !== Object.keys(e).length) return !0; for (let r = 0; r < s.length; r++) { const o = s[r]; if (t[o] !== e[o] && !ts(n, o)) return !0 } return !1 } function ba({ vnode: e, parent: t }, n) { for (; t;) { const s = t.subTree; if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e) (e = t.vnode).el = n, t = t.parent; else break } } const jo = {}, Lo = () => Object.create(jo), Uo = e => Object.getPrototypeOf(e) === jo; function ya(e, t, n, s = !1) { const r = {}, o = Lo(); e.propsDefaults = Object.create(null), Ho(e, t, r, o); for (const i in e.propsOptions[0]) i in r || (r[i] = void 0); process.env.NODE_ENV !== "production" && Ko(t || {}, r, e), n ? e.props = s ? r : nl(r) : e.type.props ? e.props = r : e.props = o, e.attrs = o } function _a(e) { for (; e;) { if (e.type.__hmrId) return !0; e = e.parent } } function va(e, t, n, s) { const { props: r, attrs: o, vnode: { patchFlag: i } } = e, c = H(r), [l] = e.propsOptions; let d = !1; if (!(process.env.NODE_ENV !== "production" && _a(e)) && (s || i > 0) && !(i & 16)) { if (i & 8) { const a = e.vnode.dynamicProps; for (let f = 0; f < a.length; f++) { let g = a[f]; if (ts(e.emitsOptions, g)) continue; const O = t[g]; if (l) if (k(o, g)) O !== o[g] && (o[g] = O, d = !0); else { const m = Ve(g); r[m] = or(l, c, m, O, e, !1) } else O !== o[g] && (o[g] = O, d = !0) } } } else { Ho(e, t, r, o) && (d = !0); let a; for (const f in c) (!t || !k(t, f) && ((a = nt(f)) === f || !k(t, a))) && (l ? n && (n[f] !== void 0 || n[a] !== void 0) && (r[f] = or(l, c, f, void 0, e, !0)) : delete r[f]); if (o !== c) for (const f in o) (!t || !k(t, f)) && (delete o[f], d = !0) } d && Ke(e.attrs, "set", ""), process.env.NODE_ENV !== "production" && Ko(t || {}, r, e) } function Ho(e, t, n, s) { const [r, o] = e.propsOptions; let i = !1, c; if (t) for (let l in t) { if (Xt(l)) continue; const d = t[l]; let a; r && k(r, a = Ve(l)) ? !o || !o.includes(a) ? n[a] = d : (c || (c = {}))[a] = d : ts(e.emitsOptions, l) || (!(l in s) || d !== s[l]) && (s[l] = d, i = !0) } if (o) { const l = H(n), d = c || W; for (let a = 0; a < o.length; a++) { const f = o[a]; n[f] = or(r, l, f, d[f], e, !k(d, f)) } } return i } function or(e, t, n, s, r, o) { const i = e[n]; if (i != null) { const c = k(i, "default"); if (c && s === void 0) { const l = i.default; if (i.type !== Function && !i.skipFactory && M(l)) { const { propsDefaults: d } = r; if (n in d) s = d[n]; else { const a = En(r); s = d[n] = l.call(null, t), a() } } else s = l; r.ce && r.ce._setProp(n, s) } i[0] && (o && !c ? s = !1 : i[1] && (s === "" || s === nt(n)) && (s = !0)) } return s } const Na = new WeakMap; function Bo(e, t, n = !1) { const s = n ? Na : t.propsCache, r = s.get(e); if (r) return r; const o = e.props, i = {}, c = []; let l = !1; if (!M(e)) { const a = f => { l = !0; const [g, O] = Bo(f, t, !0); ne(i, g), O && c.push(...O) }; !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } if (!o && !l) return G(e) && s.set(e, Ft), Ft; if ($(o)) for (let a = 0; a < o.length; a++) { process.env.NODE_ENV !== "production" && !ee(o[a]) && x("props must be strings when using array syntax.", o[a]); const f = Ve(o[a]); ko(f) && (i[f] = W) } else if (o) { process.env.NODE_ENV !== "production" && !G(o) && x("invalid props options", o); for (const a in o) { const f = Ve(a); if (ko(f)) { const g = o[a], O = i[f] = $(g) || M(g) ? { type: g } : ne({}, g), m = O.type; let y = !1, C = !0; if ($(m)) for (let P = 0; P < m.length; ++P) { const F = m[P], V = M(F) && F.name; if (V === "Boolean") { y = !0; break } else V === "String" && (C = !1) } else y = M(m) && m.name === "Boolean"; O[0] = y, O[1] = C, (y || k(O, "default")) && c.push(f) } } } const d = [i, c]; return G(e) && s.set(e, d), d } function ko(e) { return e[0] !== "$" && !Xt(e) ? !0 : (process.env.NODE_ENV !== "production" && x(`Invalid prop name: "${e}" is a reserved property.`), !1) } function Oa(e) { return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || "" } function Ko(e, t, n) { const s = H(t), r = n.propsOptions[0], o = Object.keys(e).map(i => Ve(i)); for (const i in r) { let c = r[i]; c != null && wa(i, s[i], c, process.env.NODE_ENV !== "production" ? We(s) : s, !o.includes(i)) } } function wa(e, t, n, s, r) { const { type: o, required: i, validator: c, skipCheck: l } = n; if (i && r) { x('Missing required prop: "' + e + '"'); return } if (!(t == null && !i)) { if (o != null && o !== !0 && !l) { let d = !1; const a = $(o) ? o : [o], f = []; for (let g = 0; g < a.length && !d; g++) { const { valid: O, expectedType: m } = xa(t, a[g]); f.push(m || ""), d = O } if (!d) { x(Da(e, t, f)); return } } c && !c(t, s) && x('Invalid prop: custom validator check failed for prop "' + e + '".') } } const Sa = tt("String,Number,Boolean,Function,Symbol,BigInt"); function xa(e, t) { let n; const s = Oa(t); if (s === "null") n = e === null; else if (Sa(s)) { const r = typeof e; n = r === s.toLowerCase(), !n && r === "object" && (n = e instanceof t) } else s === "Object" ? n = G(e) : s === "Array" ? n = $(e) : n = e instanceof t; return { valid: n, expectedType: s } } function Da(e, t, n) { if (n.length === 0) return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`; let s = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(An).join(" | ")}`; const r = n[0], o = xs(t), i = Wo(t, r), c = Wo(t, o); return n.length === 1 && qo(r) && !Ca(r, o) && (s += ` with value ${i}`), s += `, got ${o} `, qo(o) && (s += `with value ${c}.`), s } function Wo(e, t) { return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}` } function qo(e) { return ["string", "number", "boolean"].some(n => e.toLowerCase() === n) } function Ca(...e) { return e.some(t => t.toLowerCase() === "boolean") } const ir = e => e === "_" || e === "_ctx" || e === "$stable", cr = e => $(e) ? e.map(Ue) : [Ue(e)], Ta = (e, t, n) => { if (t._n) return t; const s = Vl((...r) => (process.env.NODE_ENV !== "production" && le && !(n === null && he) && !(n && n.root !== le.root) && x(`Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), cr(t(...r))), n); return s._c = !1, s }, Jo = (e, t, n) => { const s = e._ctx; for (const r in e) { if (ir(r)) continue; const o = e[r]; if (M(o)) t[r] = Ta(r, o, s); else if (o != null) { process.env.NODE_ENV !== "production" && x(`Non-function value encountered for slot "${r}". Prefer function slots for better performance.`); const i = cr(o); t[r] = () => i } } }, zo = (e, t) => { process.env.NODE_ENV !== "production" && !Ys(e.vnode) && x("Non-function value encountered for default slot. Prefer function slots for better performance."); const n = cr(t); e.slots.default = () => n }, lr = (e, t, n) => { for (const s in t) (n || !ir(s)) && (e[s] = t[s]) }, Ra = (e, t, n) => { const s = e.slots = Lo(); if (e.vnode.shapeFlag & 32) { const r = t._; r ? (lr(s, t, n), n && Pn(s, "_", r, !0)) : Jo(t, s) } else t && zo(e, t) }, Va = (e, t, n) => { const { vnode: s, slots: r } = e; let o = !0, i = W; if (s.shapeFlag & 32) { const c = t._; c ? process.env.NODE_ENV !== "production" && je ? (lr(r, t, n), Ke(e, "set", "$slots")) : n && c === 1 ? o = !1 : lr(r, t, n) : (o = !t.$stable, Jo(t, r)), i = t } else t && (zo(e, t), i = { default: 1 }); if (o) for (const c in r) !ir(c) && i[c] == null && delete r[c] }; let dn, it; function kt(e, t) { e.appContext.config.performance && ss() && it.mark(`vue-${t}-${e.uid}`), process.env.NODE_ENV !== "production" && Cl(e, t, ss() ? it.now() : Date.now()) } function Kt(e, t) { if (e.appContext.config.performance && ss()) { const n = `vue-${t}-${e.uid}`, s = n + ":end", r = `<${yn(e, e.type)}> ${t}`; it.mark(s), it.measure(r, n, s), it.clearMeasures(r), it.clearMarks(n), it.clearMarks(s) } process.env.NODE_ENV !== "production" && Tl(e, t, ss() ? it.now() : Date.now()) } function ss() { return dn !== void 0 || (typeof window < "u" && window.performance ? (dn = !0, it = window.performance) : dn = !1), dn } function Aa() {
        const e = []; if (process.env.NODE_ENV !== "production" && e.length) {
            const t = e.length > 1; console.warn(`Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`)
        }
    } const Oe = Ma; function Pa(e) { return Fa(e) } function Fa(e, t) { Aa(); const n = Yt(); n.__VUE__ = !0, process.env.NODE_ENV !== "production" && zs(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n); const { insert: s, remove: r, patchProp: o, createElement: i, createText: c, createComment: l, setText: d, setElementText: a, parentNode: f, nextSibling: g, setScopeId: O = ie, insertStaticContent: m } = e, y = (u, p, E, N = null, _ = null, b = null, D = void 0, w = null, S = process.env.NODE_ENV !== "production" && je ? !1 : !!p.dynamicChildren) => { if (u === p) return; u && !gn(u, p) && (N = Os(u), Re(u, _, b, !0), u = null), p.patchFlag === -2 && (S = !1, p.dynamicChildren = null); const { type: v, ref: I, shapeFlag: T } = p; switch (v) { case pn: C(u, p, E, N); break; case we: P(u, p, E, N); break; case os: u == null ? F(p, E, N, D) : process.env.NODE_ENV !== "production" && V(u, p, E, D); break; case Ce: Xe(u, p, E, N, _, b, D, w, S); break; default: T & 1 ? z(u, p, E, N, _, b, D, w, S) : T & 6 ? Ye(u, p, E, N, _, b, D, w, S) : T & 64 || T & 128 ? v.process(u, p, E, N, _, b, D, w, S, Dn) : process.env.NODE_ENV !== "production" && x("Invalid VNode type:", v, `(${typeof v})`) }I != null && _ ? an(I, u && u.ref, b, p || u, !p) : I == null && u && u.ref != null && an(u.ref, null, b, u, !0) }, C = (u, p, E, N) => { if (u == null) s(p.el = c(p.children), E, N); else { const _ = p.el = u.el; if (p.children !== u.children) if (process.env.NODE_ENV !== "production" && je && p.patchFlag === -1 && "__elIndex" in u) { const b = E.childNodes, D = c(p.children), w = b[p.__elIndex = u.__elIndex]; s(D, E, w), r(w) } else d(_, p.children) } }, P = (u, p, E, N) => { u == null ? s(p.el = l(p.children || ""), E, N) : p.el = u.el }, F = (u, p, E, N) => { [u.el, u.anchor] = m(u.children, p, E, N, u.el, u.anchor) }, V = (u, p, E, N) => { if (p.children !== u.children) { const _ = g(u.anchor); R(u), [p.el, p.anchor] = m(p.children, E, _, N) } else p.el = u.el, p.anchor = u.anchor }, J = ({ el: u, anchor: p }, E, N) => { let _; for (; u && u !== p;)_ = g(u), s(u, E, N), u = _; s(p, E, N) }, R = ({ el: u, anchor: p }) => { let E; for (; u && u !== p;)E = g(u), r(u), u = E; r(p) }, z = (u, p, E, N, _, b, D, w, S) => { if (p.type === "svg" ? D = "svg" : p.type === "math" && (D = "mathml"), u == null) Z(p, E, N, _, b, D, w, S); else { const v = u.el && u.el._isVueCE ? u.el : null; try { v && v._beginPatch(), Te(u, p, _, b, D, w, S) } finally { v && v._endPatch() } } }, Z = (u, p, E, N, _, b, D, w) => { let S, v; const { props: I, shapeFlag: T, transition: A, dirs: j } = u; if (S = u.el = i(u.type, b, I && I.is, I), T & 8 ? a(S, u.children) : T & 16 && ae(u.children, S, null, N, _, ar(u, b), D, w), j && xt(u, null, N, "created"), oe(S, u, u.scopeId, D, N), I) { for (const Y in I) Y !== "value" && !Xt(Y) && o(S, Y, null, I[Y], b, N); "value" in I && o(S, "value", null, I.value, b), (v = I.onVnodeBeforeMount) && ze(v, N, u) } process.env.NODE_ENV !== "production" && (Pn(S, "__vnode", u, !0), Pn(S, "__vueParentComponent", N, !0)), j && xt(u, null, N, "beforeMount"); const K = $a(_, A); K && A.beforeEnter(S), s(S, p, E), ((v = I && I.onVnodeMounted) || K || j) && Oe(() => { v && ze(v, N, u), K && A.enter(S), j && xt(u, null, N, "mounted") }, _) }, oe = (u, p, E, N, _) => { if (E && O(u, E), N) for (let b = 0; b < N.length; b++)O(u, N[b]); if (_) { let b = _.subTree; if (process.env.NODE_ENV !== "production" && b.patchFlag > 0 && b.patchFlag & 2048 && (b = rr(b.children) || b), p === b || Zo(b.type) && (b.ssContent === p || b.ssFallback === p)) { const D = _.vnode; oe(u, D, D.scopeId, D.slotScopeIds, _.parent) } } }, ae = (u, p, E, N, _, b, D, w, S = 0) => { for (let v = S; v < u.length; v++) { const I = u[v] = w ? bt(u[v]) : Ue(u[v]); y(null, I, p, E, N, _, b, D, w) } }, Te = (u, p, E, N, _, b, D) => { const w = p.el = u.el; process.env.NODE_ENV !== "production" && (w.__vnode = p); let { patchFlag: S, dynamicChildren: v, dirs: I } = p; S |= u.patchFlag & 16; const T = u.props || W, A = p.props || W; let j; if (E && Ct(E, !1), (j = A.onVnodeBeforeUpdate) && ze(j, E, p, u), I && xt(p, u, E, "beforeUpdate"), E && Ct(E, !0), process.env.NODE_ENV !== "production" && je && (S = 0, D = !1, v = null), (T.innerHTML && A.innerHTML == null || T.textContent && A.textContent == null) && a(w, ""), v ? (Be(u.dynamicChildren, v, w, E, N, ar(p, _), b), process.env.NODE_ENV !== "production" && rs(u, p)) : D || xe(u, p, w, null, E, N, ar(p, _), b, !1), S > 0) { if (S & 16) fe(w, T, A, E, _); else if (S & 2 && T.class !== A.class && o(w, "class", null, A.class, _), S & 4 && o(w, "style", T.style, A.style, _), S & 8) { const K = p.dynamicProps; for (let Y = 0; Y < K.length; Y++) { const X = K[Y], ve = T[X], Ne = A[X]; (Ne !== ve || X === "value") && o(w, X, ve, Ne, _, E) } } S & 1 && u.children !== p.children && a(w, p.children) } else !D && v == null && fe(w, T, A, E, _); ((j = A.onVnodeUpdated) || I) && Oe(() => { j && ze(j, E, p, u), I && xt(p, u, E, "updated") }, N) }, Be = (u, p, E, N, _, b, D) => { for (let w = 0; w < p.length; w++) { const S = u[w], v = p[w], I = S.el && (S.type === Ce || !gn(S, v) || S.shapeFlag & 198) ? f(S.el) : E; y(S, v, I, null, N, _, b, D, !0) } }, fe = (u, p, E, N, _) => { if (p !== E) { if (p !== W) for (const b in p) !Xt(b) && !(b in E) && o(u, b, p[b], null, _, N); for (const b in E) { if (Xt(b)) continue; const D = E[b], w = p[b]; D !== w && b !== "value" && o(u, b, w, D, _, N) } "value" in E && o(u, "value", p.value, E.value, _) } }, Xe = (u, p, E, N, _, b, D, w, S) => { const v = p.el = u ? u.el : c(""), I = p.anchor = u ? u.anchor : c(""); let { patchFlag: T, dynamicChildren: A, slotScopeIds: j } = p; process.env.NODE_ENV !== "production" && (je || T & 2048) && (T = 0, S = !1, A = null), j && (w = w ? w.concat(j) : j), u == null ? (s(v, E, N), s(I, E, N), ae(p.children || [], E, I, _, b, D, w, S)) : T > 0 && T & 64 && A && u.dynamicChildren && u.dynamicChildren.length === A.length ? (Be(u.dynamicChildren, A, E, _, b, D, w), process.env.NODE_ENV !== "production" ? rs(u, p) : (p.key != null || _ && p === _.subTree) && rs(u, p, !0)) : xe(u, p, E, I, _, b, D, w, S) }, Ye = (u, p, E, N, _, b, D, w, S) => { p.slotScopeIds = w, u == null ? p.shapeFlag & 512 ? _.ctx.activate(p, E, N, D, S) : ke(p, E, N, _, b, D, S) : Q(u, p, S) }, ke = (u, p, E, N, _, b, D) => { const w = u.component = qa(u, N, _); if (process.env.NODE_ENV !== "production" && w.type.__hmrId && yl(w), process.env.NODE_ENV !== "production" && (kn(u), kt(w, "mount")), Ys(u) && (w.ctx.renderer = Dn), process.env.NODE_ENV !== "production" && kt(w, "init"), za(w, !1, D), process.env.NODE_ENV !== "production" && Kt(w, "init"), process.env.NODE_ENV !== "production" && je && (u.el = null), w.asyncDep) { if (_ && _.registerDep(w, B, D), !u.el) { const S = w.subTree = ct(we); P(null, S, p, E), u.placeholder = S.el } } else B(w, u, p, E, _, b, D); process.env.NODE_ENV !== "production" && (Kn(), Kt(w, "mount")) }, Q = (u, p, E) => { const N = p.component = u.component; if (Ea(u, p, E)) if (N.asyncDep && !N.asyncResolved) { process.env.NODE_ENV !== "production" && kn(p), L(N, p, E), process.env.NODE_ENV !== "production" && Kn(); return } else N.next = p, N.update(); else p.el = u.el, N.vnode = p }, B = (u, p, E, N, _, b, D) => { const w = () => { if (u.isMounted) { let { next: T, bu: A, u: j, parent: K, vnode: Y } = u; { const Qe = Go(u); if (Qe) { T && (T.el = Y.el, L(u, T, D)), Qe.asyncDep.then(() => { u.isUnmounted || w() }); return } } let X = T, ve; process.env.NODE_ENV !== "production" && kn(T || u.vnode), Ct(u, !1), T ? (T.el = Y.el, L(u, T, D)) : T = Y, A && $t(A), (ve = T.props && T.props.onVnodeBeforeUpdate) && ze(ve, K, T, Y), Ct(u, !0), process.env.NODE_ENV !== "production" && kt(u, "render"); const Ne = Fo(u); process.env.NODE_ENV !== "production" && Kt(u, "render"); const Ze = u.subTree; u.subTree = Ne, process.env.NODE_ENV !== "production" && kt(u, "patch"), y(Ze, Ne, f(Ze.el), Os(Ze), u, _, b), process.env.NODE_ENV !== "production" && Kt(u, "patch"), T.el = Ne.el, X === null && ba(u, Ne.el), j && Oe(j, _), (ve = T.props && T.props.onVnodeUpdated) && Oe(() => ze(ve, K, T, Y), _), process.env.NODE_ENV !== "production" && ho(u), process.env.NODE_ENV !== "production" && Kn() } else { let T; const { el: A, props: j } = p, { bm: K, m: Y, parent: X, root: ve, type: Ne } = u, Ze = un(p); Ct(u, !1), K && $t(K), !Ze && (T = j && j.onVnodeBeforeMount) && ze(T, X, p), Ct(u, !0); { ve.ce && ve.ce._def.shadowRoot !== !1 && ve.ce._injectChildStyle(Ne), process.env.NODE_ENV !== "production" && kt(u, "render"); const Qe = u.subTree = Fo(u); process.env.NODE_ENV !== "production" && Kt(u, "render"), process.env.NODE_ENV !== "production" && kt(u, "patch"), y(null, Qe, E, N, u, _, b), process.env.NODE_ENV !== "production" && Kt(u, "patch"), p.el = Qe.el } if (Y && Oe(Y, _), !Ze && (T = j && j.onVnodeMounted)) { const Qe = p; Oe(() => ze(T, X, Qe), _) } (p.shapeFlag & 256 || X && un(X.vnode) && X.vnode.shapeFlag & 256) && u.a && Oe(u.a, _), u.isMounted = !0, process.env.NODE_ENV !== "production" && Sl(u), p = E = N = null } }; u.scope.on(); const S = u.effect = new Mr(w); u.scope.off(); const v = u.update = S.run.bind(S), I = u.job = S.runIfDirty.bind(S); I.i = u, I.id = u.uid, S.scheduler = () => qn(I), Ct(u, !0), process.env.NODE_ENV !== "production" && (S.onTrack = u.rtc ? T => $t(u.rtc, T) : void 0, S.onTrigger = u.rtg ? T => $t(u.rtg, T) : void 0), v() }, L = (u, p, E) => { p.component = u; const N = u.vnode.props; u.vnode = p, u.next = null, va(u, p.props, N, E), Va(u, p.children, E), Fe(), lo(u), $e() }, xe = (u, p, E, N, _, b, D, w, S = !1) => { const v = u && u.children, I = u ? u.shapeFlag : 0, T = p.children, { patchFlag: A, shapeFlag: j } = p; if (A > 0) { if (A & 128) { _e(v, T, E, N, _, b, D, w, S); return } else if (A & 256) { Sn(v, T, E, N, _, b, D, w, S); return } } j & 8 ? (I & 16 && xn(v, _, b), T !== v && a(E, T)) : I & 16 ? j & 16 ? _e(v, T, E, N, _, b, D, w, S) : xn(v, _, b, !0) : (I & 8 && a(E, ""), j & 16 && ae(T, E, N, _, b, D, w, S)) }, Sn = (u, p, E, N, _, b, D, w, S) => { u = u || Ft, p = p || Ft; const v = u.length, I = p.length, T = Math.min(v, I); let A; for (A = 0; A < T; A++) { const j = p[A] = S ? bt(p[A]) : Ue(p[A]); y(u[A], j, E, null, _, b, D, w, S) } v > I ? xn(u, _, b, !0, !1, T) : ae(p, E, N, _, b, D, w, S, T) }, _e = (u, p, E, N, _, b, D, w, S) => { let v = 0; const I = p.length; let T = u.length - 1, A = I - 1; for (; v <= T && v <= A;) { const j = u[v], K = p[v] = S ? bt(p[v]) : Ue(p[v]); if (gn(j, K)) y(j, K, E, null, _, b, D, w, S); else break; v++ } for (; v <= T && v <= A;) { const j = u[T], K = p[A] = S ? bt(p[A]) : Ue(p[A]); if (gn(j, K)) y(j, K, E, null, _, b, D, w, S); else break; T--, A-- } if (v > T) { if (v <= A) { const j = A + 1, K = j < I ? p[j].el : N; for (; v <= A;)y(null, p[v] = S ? bt(p[v]) : Ue(p[v]), E, K, _, b, D, w, S), v++ } } else if (v > A) for (; v <= T;)Re(u[v], _, b, !0), v++; else { const j = v, K = v, Y = new Map; for (v = K; v <= A; v++) { const ge = p[v] = S ? bt(p[v]) : Ue(p[v]); ge.key != null && (process.env.NODE_ENV !== "production" && Y.has(ge.key) && x("Duplicate keys found during update:", JSON.stringify(ge.key), "Make sure keys are unique."), Y.set(ge.key, v)) } let X, ve = 0; const Ne = A - K + 1; let Ze = !1, Qe = 0; const Cn = new Array(Ne); for (v = 0; v < Ne; v++)Cn[v] = 0; for (v = j; v <= T; v++) { const ge = u[v]; if (ve >= Ne) { Re(ge, _, b, !0); continue } let et; if (ge.key != null) et = Y.get(ge.key); else for (X = K; X <= A; X++)if (Cn[X - K] === 0 && gn(ge, p[X])) { et = X; break } et === void 0 ? Re(ge, _, b, !0) : (Cn[et - K] = v + 1, et >= Qe ? Qe = et : Ze = !0, y(ge, p[et], E, null, _, b, D, w, S), ve++) } const Ec = Ze ? Ia(Cn) : Ft; for (X = Ec.length - 1, v = Ne - 1; v >= 0; v--) { const ge = K + v, et = p[ge], bc = p[ge + 1], yc = ge + 1 < I ? bc.el || Yo(bc) : N; Cn[v] === 0 ? y(null, et, E, yc, _, b, D, w, S) : Ze && (X < 0 || v !== Ec[X] ? De(et, E, yc, 2) : X--) } } }, De = (u, p, E, N, _ = null) => { const { el: b, type: D, transition: w, children: S, shapeFlag: v } = u; if (v & 6) { De(u.component.subTree, p, E, N); return } if (v & 128) { u.suspense.move(p, E, N); return } if (v & 64) { D.move(u, p, E, Dn); return } if (D === Ce) { s(b, p, E); for (let T = 0; T < S.length; T++)De(S[T], p, E, N); s(u.anchor, p, E); return } if (D === os) { J(u, p, E); return } if (N !== 2 && v & 1 && w) if (N === 0) w.beforeEnter(b), s(b, p, E), Oe(() => w.enter(b), _); else { const { leave: T, delayLeave: A, afterLeave: j } = w, K = () => { u.ctx.isUnmounted ? r(b) : s(b, p, E) }, Y = () => { b._isLeaving && b[Ll](!0), T(b, () => { K(), j && j() }) }; A ? A(b, K, Y) : Y() } else s(b, p, E) }, Re = (u, p, E, N = !1, _ = !1) => { const { type: b, props: D, ref: w, children: S, dynamicChildren: v, shapeFlag: I, patchFlag: T, dirs: A, cacheIndex: j } = u; if (T === -2 && (_ = !1), w != null && (Fe(), an(w, null, E, u, !0), $e()), j != null && (p.renderCache[j] = void 0), I & 256) { p.ctx.deactivate(u); return } const K = I & 1 && A, Y = !un(u); let X; if (Y && (X = D && D.onVnodeBeforeUnmount) && ze(X, p, u), I & 6) gd(u.component, E, N); else { if (I & 128) { u.suspense.unmount(E, N); return } K && xt(u, null, p, "beforeUnmount"), I & 64 ? u.type.remove(u, p, E, Dn, N) : v && !v.hasOnce && (b !== Ce || T > 0 && T & 64) ? xn(v, p, E, !1, !0) : (b === Ce && T & 384 || !_ && I & 16) && xn(S, p, E), N && yt(u) } (Y && (X = D && D.onVnodeUnmounted) || K) && Oe(() => { X && ze(X, p, u), K && xt(u, null, p, "unmounted") }, E) }, yt = u => { const { type: p, el: E, anchor: N, transition: _ } = u; if (p === Ce) { process.env.NODE_ENV !== "production" && u.patchFlag > 0 && u.patchFlag & 2048 && _ && !_.persisted ? u.children.forEach(D => { D.type === we ? r(D.el) : yt(D) }) : Ns(E, N); return } if (p === os) { R(u); return } const b = () => { r(E), _ && !_.persisted && _.afterLeave && _.afterLeave() }; if (u.shapeFlag & 1 && _ && !_.persisted) { const { leave: D, delayLeave: w } = _, S = () => D(E, b); w ? w(u.el, b, S) : S() } else b() }, Ns = (u, p) => { let E; for (; u !== p;)E = g(u), r(u), u = E; r(p) }, gd = (u, p, E) => { process.env.NODE_ENV !== "production" && u.type.__hmrId && _l(u); const { bum: N, scope: _, job: b, subTree: D, um: w, m: S, a: v } = u; Xo(S), Xo(v), N && $t(N), _.stop(), b && (b.flags |= 8, Re(D, u, p, E)), w && Oe(w, p), Oe(() => { u.isUnmounted = !0 }, p), process.env.NODE_ENV !== "production" && Dl(u) }, xn = (u, p, E, N = !1, _ = !1, b = 0) => { for (let D = b; D < u.length; D++)Re(u[D], p, E, N, _) }, Os = u => { if (u.shapeFlag & 6) return Os(u.component.subTree); if (u.shapeFlag & 128) return u.suspense.next(); const p = g(u.anchor || u.el), E = p && p[Ml]; return E ? g(E) : p }; let Cr = !1; const gc = (u, p, E) => { let N; u == null ? p._vnode && (Re(p._vnode, null, null, !0), N = p._vnode.component) : y(p._vnode || null, u, p, null, null, null, E), p._vnode = u, Cr || (Cr = !0, lo(N), ao(), Cr = !1) }, Dn = { p: y, um: Re, m: De, r: yt, mt: ke, mc: ae, pc: xe, pbc: Be, n: Os, o: e }; return { render: gc, hydrate: void 0, createApp: fa(gc) } } function ar({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function Ct({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function $a(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function rs(e, t, n = !1) { const s = e.children, r = t.children; if ($(s) && $(r)) for (let o = 0; o < s.length; o++) { const i = s[o]; let c = r[o]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = r[o] = bt(r[o]), c.el = i.el), !n && c.patchFlag !== -2 && rs(i, c)), c.type === pn && (c.patchFlag !== -1 ? c.el = i.el : c.__elIndex = o + (e.type === Ce ? 1 : 0)), c.type === we && !c.el && (c.el = i.el), process.env.NODE_ENV !== "production" && c.el && (c.el.__vnode = c) } } function Ia(e) { const t = e.slice(), n = [0]; let s, r, o, i, c; const l = e.length; for (s = 0; s < l; s++) { const d = e[s]; if (d !== 0) { if (r = n[n.length - 1], e[r] < d) { t[s] = r, n.push(s); continue } for (o = 0, i = n.length - 1; o < i;)c = o + i >> 1, e[n[c]] < d ? o = c + 1 : i = c; d < e[n[o]] && (o > 0 && (t[s] = n[o - 1]), n[o] = s) } } for (o = n.length, i = n[o - 1]; o-- > 0;)n[o] = i, i = t[i]; return n } function Go(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Go(t) } function Xo(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } function Yo(e) { if (e.placeholder) return e.placeholder; const t = e.component; return t ? Yo(t.subTree) : null } const Zo = e => e.__isSuspense; function Ma(e, t) { t && t.pendingBranch ? $(e) ? t.effects.push(...e) : t.effects.push(e) : co(e) } const Ce = Symbol.for("v-fgt"), pn = Symbol.for("v-txt"), we = Symbol.for("v-cmt"), os = Symbol.for("v-stc"), hn = []; let Se = null; function gt(e = !1) { hn.push(Se = e ? null : []) } function ja() { hn.pop(), Se = hn[hn.length - 1] || null } let mn = 1; function Qo(e, t = !1) { mn += e, e < 0 && Se && t && (Se.hasOnce = !0) } function ei(e) { return e.dynamicChildren = mn > 0 ? Se || Ft : null, ja(), mn > 0 && Se && Se.push(e), e } function Tt(e, t, n, s, r, o) { return ei(se(e, t, n, s, r, o, !0)) } function La(e, t, n, s, r) { return ei(ct(e, t, n, s, r, !0)) } function is(e) { return e ? e.__v_isVNode === !0 : !1 } function gn(e, t) { if (process.env.NODE_ENV !== "production" && t.shapeFlag & 6 && e.component) { const n = Jn.get(t.type); if (n && n.has(e.component)) return e.shapeFlag &= -257, t.shapeFlag &= -513, !1 } return e.type === t.type && e.key === t.key } const Ua = (...e) => ni(...e), ti = ({ key: e }) => e ?? null, cs = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? ee(e) || re(e) || M(e) ? { i: he, r: e, k: t, f: !!n } : e : null); function se(e, t = null, n = null, s = 0, r = null, o = e === Ce ? 0 : 1, i = !1, c = !1) { const l = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && ti(t), ref: t && cs(t), scopeId: go, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: o, patchFlag: s, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: he }; return c ? (ur(l, n), o & 128 && e.normalize(l)) : n && (l.shapeFlag |= ee(n) ? 8 : 16), process.env.NODE_ENV !== "production" && l.key !== l.key && x("VNode created with invalid key (NaN). VNode type:", l.type), mn > 0 && !i && Se && (l.patchFlag > 0 || o & 6) && l.patchFlag !== 32 && Se.push(l), l } const ct = process.env.NODE_ENV !== "production" ? Ua : ni; function ni(e, t = null, n = null, s = 0, r = null, o = !1) {
        if ((!e || e === Ql) && (process.env.NODE_ENV !== "production" && !e && x(`Invalid vnode type when creating vnode: ${e}.`), e = we), is(e)) { const c = Et(e, t, !0); return n && ur(c, n), mn > 0 && !o && Se && (c.shapeFlag & 6 ? Se[Se.indexOf(e)] = c : Se.push(c)), c.patchFlag = -2, c } if (fi(e) && (e = e.__vccOpts), t) { t = Ha(t); let { class: c, style: l } = t; c && !ee(c) && (t.class = Zt(c)), G(l) && (Un(l) && !$(l) && (l = ne({}, l)), t.style = dt(l)) } const i = ee(e) ? 1 : Zo(e) ? 128 : jl(e) ? 64 : G(e) ? 4 : M(e) ? 2 : 0; return process.env.NODE_ENV !== "production" && i & 4 && Un(e) && (e = H(e), x("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, e)), se(e, t, n, s, r, i, o, !0)
    } function Ha(e) { return e ? Un(e) || Uo(e) ? ne({}, e) : e : null } function Et(e, t, n = !1, s = !1) { const { props: r, ref: o, patchFlag: i, children: c, transition: l } = e, d = t ? ka(r || {}, t) : r, a = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: d, key: d && ti(d), ref: t && t.ref ? n && o ? $(o) ? o.concat(cs(t)) : [o, cs(t)] : cs(t) : o, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: process.env.NODE_ENV !== "production" && i === -1 && $(c) ? c.map(si) : c, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Ce ? i === -1 ? 16 : i | 16 : i, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: l, component: e.component, suspense: e.suspense, ssContent: e.ssContent && Et(e.ssContent), ssFallback: e.ssFallback && Et(e.ssFallback), placeholder: e.placeholder, el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return l && s && Xs(a, l.clone(a)), a } function si(e) { const t = Et(e); return $(e.children) && (t.children = e.children.map(si)), t } function Ba(e = " ", t = 0) { return ct(pn, null, e, t) } function ls(e = "", t = !1) { return t ? (gt(), La(we, null, e)) : ct(we, null, e) } function Ue(e) { return e == null || typeof e == "boolean" ? ct(we) : $(e) ? ct(Ce, null, e.slice()) : is(e) ? bt(e) : ct(pn, null, String(e)) } function bt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : Et(e) } function ur(e, t) { let n = 0; const { shapeFlag: s } = e; if (t == null) t = null; else if ($(t)) n = 16; else if (typeof t == "object") if (s & 65) { const r = t.default; r && (r._c && (r._d = !1), ur(e, r()), r._c && (r._d = !0)); return } else { n = 32; const r = t._; !r && !Uo(t) ? t._ctx = he : r === 3 && he && (he.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else M(t) ? (t = { default: t, _ctx: he }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [Ba(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function ka(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n]; for (const r in s) if (r === "class") t.class !== s.class && (t.class = Zt([t.class, s.class])); else if (r === "style") t.style = dt([t.style, s.style]); else if (Gt(r)) { const o = t[r], i = s[r]; i && o !== i && !($(o) && o.includes(i)) && (t[r] = o ? [].concat(o, i) : i) } else r !== "" && (t[r] = s[r]) } return t } function ze(e, t, n, s = null) { qe(e, t, 7, [n, s]) } const Ka = Ao(); let Wa = 0; function qa(e, t, n) { const s = e.type, r = (t ? t.appContext : e.appContext) || Ka, o = { uid: Wa++, vnode: e, type: s, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new Ic(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: Bo(s, r), emitsOptions: Po(s, r), emit: null, emitted: null, propsDefaults: W, inheritAttrs: s.inheritAttrs, ctx: W, data: W, props: W, attrs: W, slots: W, refs: W, setupState: W, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return process.env.NODE_ENV !== "production" ? o.ctx = ta(o) : o.ctx = { _: o }, o.root = t ? t.root : o, o.emit = pa.bind(null, o), e.ce && e.ce(o), o } let le = null; const ri = () => le || he; let as, fr; { const e = Yt(), t = (n, s) => { let r; return (r = e[n]) || (r = e[n] = []), r.push(s), o => { r.length > 1 ? r.forEach(i => i(o)) : r[0](o) } }; as = t("__VUE_INSTANCE_SETTERS__", n => le = n), fr = t("__VUE_SSR_SETTERS__", n => bn = n) } const En = e => { const t = le; return as(e), e.scope.on(), () => { e.scope.off(), as(t) } }, oi = () => { le && le.scope.off(), as(null) }, Ja = tt("slot,component"); function dr(e, { isNativeTag: t }) { (Ja(e) || t(e)) && x("Do not use built-in or reserved HTML elements as component id: " + e) } function ii(e) { return e.vnode.shapeFlag & 4 } let bn = !1; function za(e, t = !1, n = !1) { t && fr(t); const { props: s, children: r } = e.vnode, o = ii(e); ya(e, s, o, t), Ra(e, r, n || t); const i = o ? Ga(e, t) : void 0; return t && fr(!1), i } function Ga(e, t) { const n = e.type; if (process.env.NODE_ENV !== "production") { if (n.name && dr(n.name, e.appContext.config), n.components) { const r = Object.keys(n.components); for (let o = 0; o < r.length; o++)dr(r[o], e.appContext.config) } if (n.directives) { const r = Object.keys(n.directives); for (let o = 0; o < r.length; o++)Eo(r[o]) } n.compilerOptions && Xa() && x('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.') } e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, So), process.env.NODE_ENV !== "production" && na(e); const { setup: s } = n; if (s) { Fe(); const r = e.setupContext = s.length > 1 ? Za(e) : null, o = En(e), i = Lt(s, e, 0, [process.env.NODE_ENV !== "production" ? We(e.props) : e.props, r]), c = Ss(i); if ($e(), o(), (c || e.sp) && !un(e) && _o(e), c) { if (i.then(oi, oi), t) return i.then(l => { ci(e, l, t) }).catch(l => { rn(l, e, 0) }); if (e.asyncDep = i, process.env.NODE_ENV !== "production" && !e.suspense) { const l = yn(e, n); x(`Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`) } } else ci(e, i, t) } else li(e, t) } function ci(e, t, n) { M(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : G(t) ? (process.env.NODE_ENV !== "production" && is(t) && x("setup() should not return VNodes directly - return a render function instead."), process.env.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t), e.setupState = no(t), process.env.NODE_ENV !== "production" && sa(e)) : process.env.NODE_ENV !== "production" && t !== void 0 && x(`setup() should return an object. Received: ${t === null ? "null" : typeof t}`), li(e, n) } const Xa = () => !0; function li(e, t, n) { const s = e.type; e.render || (e.render = s.render || ie); { const r = En(e); Fe(); try { oa(e) } finally { $e(), r() } } process.env.NODE_ENV !== "production" && !s.render && e.render === ie && !t && (s.template ? x('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : x("Component is missing template or render function: ", s)) } const ai = process.env.NODE_ENV !== "production" ? { get(e, t) { return ns(), ce(e, "get", ""), e[t] }, set() { return x("setupContext.attrs is readonly."), !1 }, deleteProperty() { return x("setupContext.attrs is readonly."), !1 } } : { get(e, t) { return ce(e, "get", ""), e[t] } }; function Ya(e) { return new Proxy(e.slots, { get(t, n) { return ce(e, "get", "$slots"), t[n] } }) } function Za(e) { const t = n => { if (process.env.NODE_ENV !== "production" && (e.exposed && x("expose() should be called only once per setup()."), n != null)) { let s = typeof n; s === "object" && ($(n) ? s = "array" : re(n) && (s = "ref")), s !== "object" && x(`expose() should be passed a plain object, received ${s}.`) } e.exposed = n || {} }; if (process.env.NODE_ENV !== "production") { let n, s; return Object.freeze({ get attrs() { return n || (n = new Proxy(e.attrs, ai)) }, get slots() { return s || (s = Ya(e)) }, get emit() { return (r, ...o) => e.emit(r, ...o) }, expose: t }) } else return { attrs: new Proxy(e.attrs, ai), slots: e.slots, emit: e.emit, expose: t } } function us(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(no(sl(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in Dt) return Dt[n](e) }, has(t, n) { return n in t || n in Dt } })) : e.proxy } const Qa = /(?:^|[-_])\w/g, eu = e => e.replace(Qa, t => t.toUpperCase()).replace(/[-_]/g, ""); function ui(e, t = !0) { return M(e) ? e.displayName || e.name : e.name || t && e.__name } function yn(e, t, n = !1) { let s = ui(t); if (!s && t.__file) { const r = t.__file.match(/([^/\\]+)\.\w+$/); r && (s = r[1]) } if (!s && e) { const r = o => { for (const i in o) if (o[i] === t) return i }; s = r(e.components) || e.parent && r(e.parent.type.components) || r(e.appContext.components) } return s ? eu(s) : n ? "App" : "Anonymous" } function fi(e) { return M(e) && "__vccOpts" in e } const Rt = (e, t) => { const n = al(e, t, bn); if (process.env.NODE_ENV !== "production") { const s = ri(); s && s.appContext.config.warnRecursiveComputed && (n._warnRecursive = !0) } return n }; function tu() { if (process.env.NODE_ENV === "production" || typeof window > "u") return; const e = { style: "color:#3ba776" }, t = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, s = { style: "color:#eb2f96" }, r = { __vue_custom_formatter: !0, header(f) { if (!G(f)) return null; if (f.__isVue) return ["div", e, "VueInstance"]; if (re(f)) { Fe(); const g = f.value; return $e(), ["div", {}, ["span", e, a(f)], "<", c(g), ">"] } else { if (ht(f)) return ["div", {}, ["span", e, de(f) ? "ShallowReactive" : "Reactive"], "<", c(f), `>${Ie(f) ? " (readonly)" : ""}`]; if (Ie(f)) return ["div", {}, ["span", e, de(f) ? "ShallowReadonly" : "Readonly"], "<", c(f), ">"] } return null }, hasBody(f) { return f && f.__isVue }, body(f) { if (f && f.__isVue) return ["div", {}, ...o(f.$)] } }; function o(f) { const g = []; f.type.props && f.props && g.push(i("props", H(f.props))), f.setupState !== W && g.push(i("setup", f.setupState)), f.data !== W && g.push(i("data", H(f.data))); const O = l(f, "computed"); O && g.push(i("computed", O)); const m = l(f, "inject"); return m && g.push(i("injected", m)), g.push(["div", {}, ["span", { style: s.style + ";opacity:0.66" }, "$ (internal): "], ["object", { object: f }]]), g } function i(f, g) { return g = ne({}, g), Object.keys(g).length ? ["div", { style: "line-height:1.25em;margin-bottom:0.6em" }, ["div", { style: "color:#476582" }, f], ["div", { style: "padding-left:1.25em" }, ...Object.keys(g).map(O => ["div", {}, ["span", s, O + ": "], c(g[O], !1)])]] : ["span", {}] } function c(f, g = !0) { return typeof f == "number" ? ["span", t, f] : typeof f == "string" ? ["span", n, JSON.stringify(f)] : typeof f == "boolean" ? ["span", s, f] : G(f) ? ["object", { object: g ? H(f) : f }] : ["span", n, String(f)] } function l(f, g) { const O = f.type; if (M(O)) return; const m = {}; for (const y in f.ctx) d(O, y, g) && (m[y] = f.ctx[y]); return m } function d(f, g, O) { const m = f[O]; if ($(m) && m.includes(g) || G(m) && g in m || f.extends && d(f.extends, g, O) || f.mixins && f.mixins.some(y => d(y, g, O))) return !0 } function a(f) { return de(f) ? "ShallowRef" : f.effect ? "ComputedRef" : "Ref" } window.devtoolsFormatters ? window.devtoolsFormatters.push(r) : window.devtoolsFormatters = [r] } const di = "3.5.27", lt = process.env.NODE_ENV !== "production" ? x : ie; process.env.NODE_ENV, process.env.NODE_ENV;/**
* @vue/runtime-dom v3.5.27
* (c) 2026-chenyunliang and Vue contributors
* @license MIT
**/let pr; const pi = typeof window < "u" && window.trustedTypes; if (pi) try { pr = pi.createPolicy("vue", { createHTML: e => e }) } catch (e) { process.env.NODE_ENV !== "production" && lt(`Error creating trusted types policy: ${e}`) } const hi = pr ? e => pr.createHTML(e) : e => e, nu = "http://www.w3.org/2000/svg", su = "http://www.w3.org/1998/Math/MathML", at = typeof document < "u" ? document : null, mi = at && at.createElement("template"), ru = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, s) => { const r = t === "svg" ? at.createElementNS(nu, e) : t === "mathml" ? at.createElementNS(su, e) : n ? at.createElement(e, { is: n }) : at.createElement(e); return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r }, createText: e => at.createTextNode(e), createComment: e => at.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => at.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, s, r, o) { const i = n ? n.previousSibling : t.lastChild; if (r && (r === o || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling));); else { mi.innerHTML = hi(s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e); const c = mi.content; if (s === "svg" || s === "mathml") { const l = c.firstChild; for (; l.firstChild;)c.appendChild(l.firstChild); c.removeChild(l) } t.insertBefore(c, n) } return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, ou = Symbol("_vtc"); function iu(e, t, n) { const s = e[ou]; s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const gi = Symbol("_vod"), cu = Symbol("_vsh"), lu = Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), au = /(?:^|;)\s*display\s*:/; function uu(e, t, n) { const s = e.style, r = ee(n); let o = !1; if (n && !r) { if (t) if (ee(t)) for (const i of t.split(";")) { const c = i.slice(0, i.indexOf(":")).trim(); n[c] == null && fs(s, c, "") } else for (const i in t) n[i] == null && fs(s, i, ""); for (const i in n) i === "display" && (o = !0), fs(s, i, n[i]) } else if (r) { if (t !== n) { const i = s[lu]; i && (n += ";" + i), s.cssText = n, o = au.test(n) } } else t && e.removeAttribute("style"); gi in e && (e[gi] = o ? s.display : "", e[cu] && (s.display = "none")) } const fu = /[^\\];\s*$/, Ei = /\s*!important$/; function fs(e, t, n) { if ($(n)) n.forEach(s => fs(e, t, s)); else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && fu.test(n) && lt(`Unexpected semicolon at the end of '${t}' style value: '${n}'`), t.startsWith("--")) e.setProperty(t, n); else { const s = du(e, t); Ei.test(n) ? e.setProperty(nt(s), n.replace(Ei, ""), "important") : e[s] = n } } const bi = ["Webkit", "Moz", "ms"], hr = {}; function du(e, t) { const n = hr[t]; if (n) return n; let s = Ve(t); if (s !== "filter" && s in e) return hr[t] = s; s = An(s); for (let r = 0; r < bi.length; r++) { const o = bi[r] + s; if (o in e) return hr[t] = o } return t } const yi = "http://www.w3.org/1999/xlink"; function _i(e, t, n, s, r, o = $c(t)) { s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(yi, t.slice(6, t.length)) : e.setAttributeNS(yi, t, n) : n == null || o && !Fr(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? "" : ut(n) ? String(n) : n) } function vi(e, t, n, s, r) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? hi(n) : n); return } const o = e.tagName; if (t === "value" && o !== "PROGRESS" && !o.includes("-")) { const c = o === "OPTION" ? e.getAttribute("value") || "" : e.value, l = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (c !== l || !("_value" in e)) && (e.value = l), n == null && e.removeAttribute(t), e._value = n; return } let i = !1; if (n === "" || n == null) { const c = typeof e[t]; c === "boolean" ? n = Fr(n) : n == null && c === "string" ? (n = "", i = !0) : c === "number" && (n = 0, i = !0) } try { e[t] = n } catch (c) { process.env.NODE_ENV !== "production" && !i && lt(`Failed setting prop "${t}" on <${o.toLowerCase()}>: value ${n} is invalid.`, c) } i && e.removeAttribute(r || t) } function Wt(e, t, n, s) { e.addEventListener(t, n, s) } function pu(e, t, n, s) { e.removeEventListener(t, n, s) } const Ni = Symbol("_vei"); function hu(e, t, n, s, r = null) { const o = e[Ni] || (e[Ni] = {}), i = o[t]; if (s && i) i.value = process.env.NODE_ENV !== "production" ? wi(s, t) : s; else { const [c, l] = mu(t); if (s) { const d = o[t] = bu(process.env.NODE_ENV !== "production" ? wi(s, t) : s, r); Wt(e, c, d, l) } else i && (pu(e, c, i, l), o[t] = void 0) } } const Oi = /(?:Once|Passive|Capture)$/; function mu(e) { let t; if (Oi.test(e)) { t = {}; let s; for (; s = e.match(Oi);)e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : nt(e.slice(2)), t] } let mr = 0; const gu = Promise.resolve(), Eu = () => mr || (gu.then(() => mr = 0), mr = Date.now()); function bu(e, t) { const n = s => { if (!s._vts) s._vts = Date.now(); else if (s._vts <= n.attached) return; qe(yu(s, n.value), t, 5, [s]) }; return n.value = e, n.attached = Eu(), n } function wi(e, t) {
        return M(e) || $(e) ? e : (lt(`Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e}.`), ie)
    } function yu(e, t) { if ($(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(s => r => !r._stopped && s && s(r)) } else return t } const Si = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, _u = (e, t, n, s, r, o) => { const i = r === "svg"; t === "class" ? iu(e, s, i) : t === "style" ? uu(e, n, s) : Gt(t) ? Tn(t) || hu(e, t, n, s, o) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : vu(e, t, s, i)) ? (vi(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && _i(e, t, s, i, o, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !ee(s)) ? vi(e, Ve(t), s, o, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), _i(e, t, s, i)) }; function vu(e, t, n, s) { if (s) return !!(t === "innerHTML" || t === "textContent" || t in e && Si(t) && M(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "sandbox" && e.tagName === "IFRAME" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const r = e.tagName; if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1 } return Si(t) && ee(n) ? !1 : t in e } const xi = e => { const t = e.props["onUpdate:modelValue"] || !1; return $(t) ? n => $t(t, n) : t }; function Nu(e) { e.target.composing = !0 } function Di(e) { const t = e.target; t.composing && (t.composing = !1, t.dispatchEvent(new Event("input"))) } const gr = Symbol("_assign"); function Ci(e, t, n) { return t && (e = e.trim()), n && (e = Cs(e)), e } const Ou = { created(e, { modifiers: { lazy: t, trim: n, number: s } }, r) { e[gr] = xi(r); const o = s || r.props && r.props.type === "number"; Wt(e, t ? "change" : "input", i => { i.target.composing || e[gr](Ci(e.value, n, o)) }), (n || o) && Wt(e, "change", () => { e.value = Ci(e.value, n, o) }), t || (Wt(e, "compositionstart", Nu), Wt(e, "compositionend", Di), Wt(e, "change", Di)) }, mounted(e, { value: t }) { e.value = t ?? "" }, beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: s, trim: r, number: o } }, i) { if (e[gr] = xi(i), e.composing) return; const c = (o || e.type === "number") && !/^0\d/.test(e.value) ? Cs(e.value) : e.value, l = t ?? ""; c !== l && (document.activeElement === e && e.type !== "range" && (s && t === n || r && e.value.trim() === l) || (e.value = l)) } }, wu = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, Su = (e, t) => { const n = e._withKeys || (e._withKeys = {}), s = t.join("."); return n[s] || (n[s] = r => { if (!("key" in r)) return; const o = nt(r.key); if (t.some(i => i === o || wu[i] === o)) return e(r) }) }, xu = ne({ patchProp: _u }, ru); let Ti; function Du() { return Ti || (Ti = Pa(xu)) } const Cu = (...e) => { const t = Du().createApp(...e); process.env.NODE_ENV !== "production" && (Ru(t), Vu(t)); const { mount: n } = t; return t.mount = s => { const r = Au(s); if (!r) return; const o = t._component; !M(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = ""); const i = n(r, !1, Tu(r)); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), i }, t }; function Tu(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function Ru(e) { Object.defineProperty(e.config, "isNativeTag", { value: t => Ac(t) || Pc(t) || Fc(t), writable: !1 }) } function Vu(e) { { const t = e.config.isCustomElement; Object.defineProperty(e.config, "isCustomElement", { get() { return t }, set() { lt("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.") } }); const n = e.config.compilerOptions, s = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc'; Object.defineProperty(e.config, "compilerOptions", { get() { return lt(s), n }, set() { lt(s) } }) } } function Au(e) { if (ee(e)) { const t = document.querySelector(e); return process.env.NODE_ENV !== "production" && !t && lt(`Failed to mount app: mount target selector "${e}" returned null.`), t } return process.env.NODE_ENV !== "production" && window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && lt('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), e }/**
* vue v3.5.27
* (c) 2026-chenyunliang and Vue contributors
* @license MIT
**/function Pu() { tu() } process.env.NODE_ENV !== "production" && Pu(); function Ri(e, t) { return function () { return e.apply(t, arguments) } } const { toString: Fu } = Object.prototype, { getPrototypeOf: Er } = Object, { iterator: ds, toStringTag: Vi } = Symbol, ps = (e => t => { const n = Fu.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), He = e => (e = e.toLowerCase(), t => ps(t) === e), hs = e => t => typeof t === e, { isArray: qt } = Array, Jt = hs("undefined"); function _n(e) { return e !== null && !Jt(e) && e.constructor !== null && !Jt(e.constructor) && be(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const Ai = He("ArrayBuffer"); function $u(e) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Ai(e.buffer), t } const Iu = hs("string"), be = hs("function"), Pi = hs("number"), vn = e => e !== null && typeof e == "object", Mu = e => e === !0 || e === !1, ms = e => { if (ps(e) !== "object") return !1; const t = Er(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Vi in e) && !(ds in e) }, ju = e => { if (!vn(e) || _n(e)) return !1; try { return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype } catch { return !1 } }, Lu = He("Date"), Uu = He("File"), Hu = He("Blob"), Bu = He("FileList"), ku = e => vn(e) && be(e.pipe), Ku = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || be(e.append) && ((t = ps(e)) === "formdata" || t === "object" && be(e.toString) && e.toString() === "[object FormData]")) }, Wu = He("URLSearchParams"), [qu, Ju, zu, Gu] = ["ReadableStream", "Request", "Response", "Headers"].map(He), Xu = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Nn(e, t, { allOwnKeys: n = !1 } = {}) { if (e === null || typeof e > "u") return; let s, r; if (typeof e != "object" && (e = [e]), qt(e)) for (s = 0, r = e.length; s < r; s++)t.call(null, e[s], s, e); else { if (_n(e)) return; const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), i = o.length; let c; for (s = 0; s < i; s++)c = o[s], t.call(null, e[c], c, e) } } function Fi(e, t) { if (_n(e)) return null; t = t.toLowerCase(); const n = Object.keys(e); let s = n.length, r; for (; s-- > 0;)if (r = n[s], t === r.toLowerCase()) return r; return null } const Vt = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, $i = e => !Jt(e) && e !== Vt; function br() { const { caseless: e, skipUndefined: t } = $i(this) && this || {}, n = {}, s = (r, o) => { const i = e && Fi(n, o) || o; ms(n[i]) && ms(r) ? n[i] = br(n[i], r) : ms(r) ? n[i] = br({}, r) : qt(r) ? n[i] = r.slice() : (!t || !Jt(r)) && (n[i] = r) }; for (let r = 0, o = arguments.length; r < o; r++)arguments[r] && Nn(arguments[r], s); return n } const Yu = (e, t, n, { allOwnKeys: s } = {}) => (Nn(t, (r, o) => { n && be(r) ? e[o] = Ri(r, n) : e[o] = r }, { allOwnKeys: s }), e), Zu = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Qu = (e, t, n, s) => { e.prototype = Object.create(t.prototype, s), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, ef = (e, t, n, s) => { let r, o, i; const c = {}; if (t = t || {}, e == null) return t; do { for (r = Object.getOwnPropertyNames(e), o = r.length; o-- > 0;)i = r[o], (!s || s(i, e, t)) && !c[i] && (t[i] = e[i], c[i] = !0); e = n !== !1 && Er(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, tf = (e, t, n) => { e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length; const s = e.indexOf(t, n); return s !== -1 && s === n }, nf = e => { if (!e) return null; if (qt(e)) return e; let t = e.length; if (!Pi(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, sf = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && Er(Uint8Array)), rf = (e, t) => { const s = (e && e[ds]).call(e); let r; for (; (r = s.next()) && !r.done;) { const o = r.value; t.call(e, o[0], o[1]) } }, of = (e, t) => { let n; const s = []; for (; (n = e.exec(t)) !== null;)s.push(n); return s }, cf = He("HTMLFormElement"), lf = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, s, r) { return s.toUpperCase() + r }), Ii = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), af = He("RegExp"), Mi = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), s = {}; Nn(n, (r, o) => { let i; (i = t(r, o, e)) !== !1 && (s[o] = i || r) }), Object.defineProperties(e, s) }, uf = e => { Mi(e, (t, n) => { if (be(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const s = e[n]; if (be(s)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, ff = (e, t) => { const n = {}, s = r => { r.forEach(o => { n[o] = !0 }) }; return qt(e) ? s(e) : s(String(e).split(t)), n }, df = () => { }, pf = (e, t) => e != null && Number.isFinite(e = +e) ? e : t; function hf(e) { return !!(e && be(e.append) && e[Vi] === "FormData" && e[ds]) } const mf = e => { const t = new Array(10), n = (s, r) => { if (vn(s)) { if (t.indexOf(s) >= 0) return; if (_n(s)) return s; if (!("toJSON" in s)) { t[r] = s; const o = qt(s) ? [] : {}; return Nn(s, (i, c) => { const l = n(i, r + 1); !Jt(l) && (o[c] = l) }), t[r] = void 0, o } } return s }; return n(e, 0) }, gf = He("AsyncFunction"), Ef = e => e && (vn(e) || be(e)) && be(e.then) && be(e.catch), ji = ((e, t) => e ? setImmediate : t ? ((n, s) => (Vt.addEventListener("message", ({ source: r, data: o }) => { r === Vt && o === n && s.length && s.shift()() }, !1), r => { s.push(r), Vt.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", be(Vt.postMessage)), bf = typeof queueMicrotask < "u" ? queueMicrotask.bind(Vt) : typeof process < "u" && process.nextTick || ji, h = { isArray: qt, isArrayBuffer: Ai, isBuffer: _n, isFormData: Ku, isArrayBufferView: $u, isString: Iu, isNumber: Pi, isBoolean: Mu, isObject: vn, isPlainObject: ms, isEmptyObject: ju, isReadableStream: qu, isRequest: Ju, isResponse: zu, isHeaders: Gu, isUndefined: Jt, isDate: Lu, isFile: Uu, isBlob: Hu, isRegExp: af, isFunction: be, isStream: ku, isURLSearchParams: Wu, isTypedArray: sf, isFileList: Bu, forEach: Nn, merge: br, extend: Yu, trim: Xu, stripBOM: Zu, inherits: Qu, toFlatObject: ef, kindOf: ps, kindOfTest: He, endsWith: tf, toArray: nf, forEachEntry: rf, matchAll: of, isHTMLForm: cf, hasOwnProperty: Ii, hasOwnProp: Ii, reduceDescriptors: Mi, freezeMethods: uf, toObjectSet: ff, toCamelCase: lf, noop: df, toFiniteNumber: pf, findKey: Fi, global: Vt, isContextDefined: $i, isSpecCompliantForm: hf, toJSONObject: mf, isAsyncFn: gf, isThenable: Ef, setImmediate: ji, asap: bf, isIterable: e => e != null && be(e[ds]) }; function U(e, t, n, s, r) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), s && (this.request = s), r && (this.response = r, this.status = r.status ? r.status : null) } h.inherits(U, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: h.toJSONObject(this.config), code: this.code, status: this.status } } }); const Li = U.prototype, Ui = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { Ui[e] = { value: e } }), Object.defineProperties(U, Ui), Object.defineProperty(Li, "isAxiosError", { value: !0 }), U.from = (e, t, n, s, r, o) => { const i = Object.create(Li); h.toFlatObject(e, i, function (a) { return a !== Error.prototype }, d => d !== "isAxiosError"); const c = e && e.message ? e.message : "Error", l = t == null && e ? e.code : t; return U.call(i, c, l, n, s, r), e && i.cause == null && Object.defineProperty(i, "cause", { value: e, configurable: !0 }), i.name = e && e.name || "Error", o && Object.assign(i, o), i }; const yf = null; function yr(e) { return h.isPlainObject(e) || h.isArray(e) } function Hi(e) { return h.endsWith(e, "[]") ? e.slice(0, -2) : e } function Bi(e, t, n) { return e ? e.concat(t).map(function (r, o) { return r = Hi(r), !n && o ? "[" + r + "]" : r }).join(n ? "." : "") : t } function _f(e) { return h.isArray(e) && !e.some(yr) } const vf = h.toFlatObject(h, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function gs(e, t, n) { if (!h.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, n = h.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (y, C) { return !h.isUndefined(C[y]) }); const s = n.metaTokens, r = n.visitor || a, o = n.dots, i = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && h.isSpecCompliantForm(t); if (!h.isFunction(r)) throw new TypeError("visitor must be a function"); function d(m) { if (m === null) return ""; if (h.isDate(m)) return m.toISOString(); if (h.isBoolean(m)) return m.toString(); if (!l && h.isBlob(m)) throw new U("Blob is not supported. Use a Buffer instead."); return h.isArrayBuffer(m) || h.isTypedArray(m) ? l && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m } function a(m, y, C) { let P = m; if (m && !C && typeof m == "object") { if (h.endsWith(y, "{}")) y = s ? y : y.slice(0, -2), m = JSON.stringify(m); else if (h.isArray(m) && _f(m) || (h.isFileList(m) || h.endsWith(y, "[]")) && (P = h.toArray(m))) return y = Hi(y), P.forEach(function (V, J) { !(h.isUndefined(V) || V === null) && t.append(i === !0 ? Bi([y], J, o) : i === null ? y : y + "[]", d(V)) }), !1 } return yr(m) ? !0 : (t.append(Bi(C, y, o), d(m)), !1) } const f = [], g = Object.assign(vf, { defaultVisitor: a, convertValue: d, isVisitable: yr }); function O(m, y) { if (!h.isUndefined(m)) { if (f.indexOf(m) !== -1) throw Error("Circular reference detected in " + y.join(".")); f.push(m), h.forEach(m, function (P, F) { (!(h.isUndefined(P) || P === null) && r.call(t, P, h.isString(F) ? F.trim() : F, y, g)) === !0 && O(P, y ? y.concat(F) : [F]) }), f.pop() } } if (!h.isObject(e)) throw new TypeError("data must be an object"); return O(e), t } function ki(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (s) { return t[s] }) } function _r(e, t) { this._pairs = [], e && gs(e, this, t) } const Ki = _r.prototype; Ki.append = function (t, n) { this._pairs.push([t, n]) }, Ki.toString = function (t) { const n = t ? function (s) { return t.call(this, s, ki) } : ki; return this._pairs.map(function (r) { return n(r[0]) + "=" + n(r[1]) }, "").join("&") }; function Nf(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function Wi(e, t, n) { if (!t) return e; const s = n && n.encode || Nf; h.isFunction(n) && (n = { serialize: n }); const r = n && n.serialize; let o; if (r ? o = r(t, n) : o = h.isURLSearchParams(t) ? t.toString() : new _r(t, n).toString(s), o) { const i = e.indexOf("#"); i !== -1 && (e = e.slice(0, i)), e += (e.indexOf("?") === -1 ? "?" : "&") + o } return e } class qi { constructor() { this.handlers = [] } use(t, n, s) { return this.handlers.push({ fulfilled: t, rejected: n, synchronous: s ? s.synchronous : !1, runWhen: s ? s.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { h.forEach(this.handlers, function (s) { s !== null && t(s) }) } } const Ji = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Of = { isBrowser: !0, classes: { URLSearchParams: typeof URLSearchParams < "u" ? URLSearchParams : _r, FormData: typeof FormData < "u" ? FormData : null, Blob: typeof Blob < "u" ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, vr = typeof window < "u" && typeof document < "u", Nr = typeof navigator == "object" && navigator || void 0, wf = vr && (!Nr || ["ReactNative", "NativeScript", "NS"].indexOf(Nr.product) < 0), Sf = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", xf = vr && window.location.href || "http://localhost", ue = { ...Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: vr, hasStandardBrowserEnv: wf, hasStandardBrowserWebWorkerEnv: Sf, navigator: Nr, origin: xf }, Symbol.toStringTag, { value: "Module" })), ...Of }; function Df(e, t) { return gs(e, new ue.classes.URLSearchParams, { visitor: function (n, s, r, o) { return ue.isNode && h.isBuffer(n) ? (this.append(s, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments) }, ...t }) } function Cf(e) { return h.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function Tf(e) { const t = {}, n = Object.keys(e); let s; const r = n.length; let o; for (s = 0; s < r; s++)o = n[s], t[o] = e[o]; return t } function zi(e) { function t(n, s, r, o) { let i = n[o++]; if (i === "__proto__") return !0; const c = Number.isFinite(+i), l = o >= n.length; return i = !i && h.isArray(r) ? r.length : i, l ? (h.hasOwnProp(r, i) ? r[i] = [r[i], s] : r[i] = s, !c) : ((!r[i] || !h.isObject(r[i])) && (r[i] = []), t(n, s, r[i], o) && h.isArray(r[i]) && (r[i] = Tf(r[i])), !c) } if (h.isFormData(e) && h.isFunction(e.entries)) { const n = {}; return h.forEachEntry(e, (s, r) => { t(Cf(s), r, n, 0) }), n } return null } function Rf(e, t, n) { if (h.isString(e)) try { return (t || JSON.parse)(e), h.trim(e) } catch (s) { if (s.name !== "SyntaxError") throw s } return (n || JSON.stringify)(e) } const On = { transitional: Ji, adapter: ["xhr", "http", "fetch"], transformRequest: [function (t, n) { const s = n.getContentType() || "", r = s.indexOf("application/json") > -1, o = h.isObject(t); if (o && h.isHTMLForm(t) && (t = new FormData(t)), h.isFormData(t)) return r ? JSON.stringify(zi(t)) : t; if (h.isArrayBuffer(t) || h.isBuffer(t) || h.isStream(t) || h.isFile(t) || h.isBlob(t) || h.isReadableStream(t)) return t; if (h.isArrayBufferView(t)) return t.buffer; if (h.isURLSearchParams(t)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let c; if (o) { if (s.indexOf("application/x-www-form-urlencoded") > -1) return Df(t, this.formSerializer).toString(); if ((c = h.isFileList(t)) || s.indexOf("multipart/form-data") > -1) { const l = this.env && this.env.FormData; return gs(c ? { "files[]": t } : t, l && new l, this.formSerializer) } } return o || r ? (n.setContentType("application/json", !1), Rf(t)) : t }], transformResponse: [function (t) { const n = this.transitional || On.transitional, s = n && n.forcedJSONParsing, r = this.responseType === "json"; if (h.isResponse(t) || h.isReadableStream(t)) return t; if (t && h.isString(t) && (s && !this.responseType || r)) { const i = !(n && n.silentJSONParsing) && r; try { return JSON.parse(t, this.parseReviver) } catch (c) { if (i) throw c.name === "SyntaxError" ? U.from(c, U.ERR_BAD_RESPONSE, this, null, this.response) : c } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: ue.classes.FormData, Blob: ue.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; h.forEach(["delete", "get", "head", "post", "put", "patch"], e => { On.headers[e] = {} }); const Vf = h.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Af = e => {
        const t = {}; let n, s, r; return e && e.split(`
`).forEach(function (i) { r = i.indexOf(":"), n = i.substring(0, r).trim().toLowerCase(), s = i.substring(r + 1).trim(), !(!n || t[n] && Vf[n]) && (n === "set-cookie" ? t[n] ? t[n].push(s) : t[n] = [s] : t[n] = t[n] ? t[n] + ", " + s : s) }), t
    }, Gi = Symbol("internals"); function wn(e) { return e && String(e).trim().toLowerCase() } function Es(e) { return e === !1 || e == null ? e : h.isArray(e) ? e.map(Es) : String(e) } function Pf(e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let s; for (; s = n.exec(e);)t[s[1]] = s[2]; return t } const Ff = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function Or(e, t, n, s, r) { if (h.isFunction(s)) return s.call(this, t, n); if (r && (t = n), !!h.isString(t)) { if (h.isString(s)) return t.indexOf(s) !== -1; if (h.isRegExp(s)) return s.test(t) } } function $f(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, s) => n.toUpperCase() + s) } function If(e, t) { const n = h.toCamelCase(" " + t);["get", "set", "has"].forEach(s => { Object.defineProperty(e, s + n, { value: function (r, o, i) { return this[s].call(this, t, r, o, i) }, configurable: !0 }) }) } let ye = class {
        constructor(t) { t && this.set(t) } set(t, n, s) { const r = this; function o(c, l, d) { const a = wn(l); if (!a) throw new Error("header name must be a non-empty string"); const f = h.findKey(r, a); (!f || r[f] === void 0 || d === !0 || d === void 0 && r[f] !== !1) && (r[f || l] = Es(c)) } const i = (c, l) => h.forEach(c, (d, a) => o(d, a, l)); if (h.isPlainObject(t) || t instanceof this.constructor) i(t, n); else if (h.isString(t) && (t = t.trim()) && !Ff(t)) i(Af(t), n); else if (h.isObject(t) && h.isIterable(t)) { let c = {}, l, d; for (const a of t) { if (!h.isArray(a)) throw TypeError("Object iterator must return a key-value pair"); c[d = a[0]] = (l = c[d]) ? h.isArray(l) ? [...l, a[1]] : [l, a[1]] : a[1] } i(c, n) } else t != null && o(n, t, s); return this } get(t, n) { if (t = wn(t), t) { const s = h.findKey(this, t); if (s) { const r = this[s]; if (!n) return r; if (n === !0) return Pf(r); if (h.isFunction(n)) return n.call(this, r, s); if (h.isRegExp(n)) return n.exec(r); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, n) { if (t = wn(t), t) { const s = h.findKey(this, t); return !!(s && this[s] !== void 0 && (!n || Or(this, this[s], s, n))) } return !1 } delete(t, n) { const s = this; let r = !1; function o(i) { if (i = wn(i), i) { const c = h.findKey(s, i); c && (!n || Or(s, s[c], c, n)) && (delete s[c], r = !0) } } return h.isArray(t) ? t.forEach(o) : o(t), r } clear(t) { const n = Object.keys(this); let s = n.length, r = !1; for (; s--;) { const o = n[s]; (!t || Or(this, this[o], o, t, !0)) && (delete this[o], r = !0) } return r } normalize(t) { const n = this, s = {}; return h.forEach(this, (r, o) => { const i = h.findKey(s, o); if (i) { n[i] = Es(r), delete n[o]; return } const c = t ? $f(o) : String(o).trim(); c !== o && delete n[o], n[c] = Es(r), s[c] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const n = Object.create(null); return h.forEach(this, (s, r) => { s != null && s !== !1 && (n[r] = t && h.isArray(s) ? s.join(", ") : s) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
            return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`)
        } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...n) { const s = new this(t); return n.forEach(r => s.set(r)), s } static accessor(t) { const s = (this[Gi] = this[Gi] = { accessors: {} }).accessors, r = this.prototype; function o(i) { const c = wn(i); s[c] || (If(r, i), s[c] = !0) } return h.isArray(t) ? t.forEach(o) : o(t), this }
    }; ye.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), h.reduceDescriptors(ye.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(s) { this[n] = s } } }), h.freezeMethods(ye); function wr(e, t) { const n = this || On, s = t || n, r = ye.from(s.headers); let o = s.data; return h.forEach(e, function (c) { o = c.call(n, o, r.normalize(), t ? t.status : void 0) }), r.normalize(), o } function Xi(e) { return !!(e && e.__CANCEL__) } function zt(e, t, n) { U.call(this, e ?? "canceled", U.ERR_CANCELED, t, n), this.name = "CanceledError" } h.inherits(zt, U, { __CANCEL__: !0 }); function Yi(e, t, n) { const s = n.config.validateStatus; !n.status || !s || s(n.status) ? e(n) : t(new U("Request failed with status code " + n.status, [U.ERR_BAD_REQUEST, U.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function Mf(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function jf(e, t) { e = e || 10; const n = new Array(e), s = new Array(e); let r = 0, o = 0, i; return t = t !== void 0 ? t : 1e3, function (l) { const d = Date.now(), a = s[o]; i || (i = d), n[r] = l, s[r] = d; let f = o, g = 0; for (; f !== r;)g += n[f++], f = f % e; if (r = (r + 1) % e, r === o && (o = (o + 1) % e), d - i < t) return; const O = a && d - a; return O ? Math.round(g * 1e3 / O) : void 0 } } function Lf(e, t) { let n = 0, s = 1e3 / t, r, o; const i = (d, a = Date.now()) => { n = a, r = null, o && (clearTimeout(o), o = null), e(...d) }; return [(...d) => { const a = Date.now(), f = a - n; f >= s ? i(d, a) : (r = d, o || (o = setTimeout(() => { o = null, i(r) }, s - f))) }, () => r && i(r)] } const bs = (e, t, n = 3) => { let s = 0; const r = jf(50, 250); return Lf(o => { const i = o.loaded, c = o.lengthComputable ? o.total : void 0, l = i - s, d = r(l), a = i <= c; s = i; const f = { loaded: i, total: c, progress: c ? i / c : void 0, bytes: l, rate: d || void 0, estimated: d && c && a ? (c - i) / d : void 0, event: o, lengthComputable: c != null, [t ? "download" : "upload"]: !0 }; e(f) }, n) }, Zi = (e, t) => { const n = e != null; return [s => t[0]({ lengthComputable: n, total: e, loaded: s }), t[1]] }, Qi = e => (...t) => h.asap(() => e(...t)), Uf = ue.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, ue.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(ue.origin), ue.navigator && /(msie|trident)/i.test(ue.navigator.userAgent)) : () => !0, Hf = ue.hasStandardBrowserEnv ? { write(e, t, n, s, r, o, i) { if (typeof document > "u") return; const c = [`${e}=${encodeURIComponent(t)}`]; h.isNumber(n) && c.push(`expires=${new Date(n).toUTCString()}`), h.isString(s) && c.push(`path=${s}`), h.isString(r) && c.push(`domain=${r}`), o === !0 && c.push("secure"), h.isString(i) && c.push(`SameSite=${i}`), document.cookie = c.join("; ") }, read(e) { if (typeof document > "u") return null; const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5, "/") } } : { write() { }, read() { return null }, remove() { } }; function Bf(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function kf(e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e } function ec(e, t, n) { let s = !Bf(t); return e && (s || n == !1) ? kf(e, t) : t } const tc = e => e instanceof ye ? { ...e } : e; function At(e, t) { t = t || {}; const n = {}; function s(d, a, f, g) { return h.isPlainObject(d) && h.isPlainObject(a) ? h.merge.call({ caseless: g }, d, a) : h.isPlainObject(a) ? h.merge({}, a) : h.isArray(a) ? a.slice() : a } function r(d, a, f, g) { if (h.isUndefined(a)) { if (!h.isUndefined(d)) return s(void 0, d, f, g) } else return s(d, a, f, g) } function o(d, a) { if (!h.isUndefined(a)) return s(void 0, a) } function i(d, a) { if (h.isUndefined(a)) { if (!h.isUndefined(d)) return s(void 0, d) } else return s(void 0, a) } function c(d, a, f) { if (f in t) return s(d, a); if (f in e) return s(void 0, d) } const l = { url: o, method: o, data: o, baseURL: i, transformRequest: i, transformResponse: i, paramsSerializer: i, timeout: i, timeoutMessage: i, withCredentials: i, withXSRFToken: i, adapter: i, responseType: i, xsrfCookieName: i, xsrfHeaderName: i, onUploadProgress: i, onDownloadProgress: i, decompress: i, maxContentLength: i, maxBodyLength: i, beforeRedirect: i, transport: i, httpAgent: i, httpsAgent: i, cancelToken: i, socketPath: i, responseEncoding: i, validateStatus: c, headers: (d, a, f) => r(tc(d), tc(a), f, !0) }; return h.forEach(Object.keys({ ...e, ...t }), function (a) { const f = l[a] || r, g = f(e[a], t[a], a); h.isUndefined(g) && f !== c || (n[a] = g) }), n } const nc = e => { const t = At({}, e); let { data: n, withXSRFToken: s, xsrfHeaderName: r, xsrfCookieName: o, headers: i, auth: c } = t; if (t.headers = i = ye.from(i), t.url = Wi(ec(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), c && i.set("Authorization", "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))), h.isFormData(n)) { if (ue.hasStandardBrowserEnv || ue.hasStandardBrowserWebWorkerEnv) i.setContentType(void 0); else if (h.isFunction(n.getHeaders)) { const l = n.getHeaders(), d = ["content-type", "content-length"]; Object.entries(l).forEach(([a, f]) => { d.includes(a.toLowerCase()) && i.set(a, f) }) } } if (ue.hasStandardBrowserEnv && (s && h.isFunction(s) && (s = s(t)), s || s !== !1 && Uf(t.url))) { const l = r && o && Hf.read(o); l && i.set(r, l) } return t }, Kf = typeof XMLHttpRequest < "u" && function (e) { return new Promise(function (n, s) { const r = nc(e); let o = r.data; const i = ye.from(r.headers).normalize(); let { responseType: c, onUploadProgress: l, onDownloadProgress: d } = r, a, f, g, O, m; function y() { O && O(), m && m(), r.cancelToken && r.cancelToken.unsubscribe(a), r.signal && r.signal.removeEventListener("abort", a) } let C = new XMLHttpRequest; C.open(r.method.toUpperCase(), r.url, !0), C.timeout = r.timeout; function P() { if (!C) return; const V = ye.from("getAllResponseHeaders" in C && C.getAllResponseHeaders()), R = { data: !c || c === "text" || c === "json" ? C.responseText : C.response, status: C.status, statusText: C.statusText, headers: V, config: e, request: C }; Yi(function (Z) { n(Z), y() }, function (Z) { s(Z), y() }, R), C = null } "onloadend" in C ? C.onloadend = P : C.onreadystatechange = function () { !C || C.readyState !== 4 || C.status === 0 && !(C.responseURL && C.responseURL.indexOf("file:") === 0) || setTimeout(P) }, C.onabort = function () { C && (s(new U("Request aborted", U.ECONNABORTED, e, C)), C = null) }, C.onerror = function (J) { const R = J && J.message ? J.message : "Network Error", z = new U(R, U.ERR_NETWORK, e, C); z.event = J || null, s(z), C = null }, C.ontimeout = function () { let J = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"; const R = r.transitional || Ji; r.timeoutErrorMessage && (J = r.timeoutErrorMessage), s(new U(J, R.clarifyTimeoutError ? U.ETIMEDOUT : U.ECONNABORTED, e, C)), C = null }, o === void 0 && i.setContentType(null), "setRequestHeader" in C && h.forEach(i.toJSON(), function (J, R) { C.setRequestHeader(R, J) }), h.isUndefined(r.withCredentials) || (C.withCredentials = !!r.withCredentials), c && c !== "json" && (C.responseType = r.responseType), d && ([g, m] = bs(d, !0), C.addEventListener("progress", g)), l && C.upload && ([f, O] = bs(l), C.upload.addEventListener("progress", f), C.upload.addEventListener("loadend", O)), (r.cancelToken || r.signal) && (a = V => { C && (s(!V || V.type ? new zt(null, e, C) : V), C.abort(), C = null) }, r.cancelToken && r.cancelToken.subscribe(a), r.signal && (r.signal.aborted ? a() : r.signal.addEventListener("abort", a))); const F = Mf(r.url); if (F && ue.protocols.indexOf(F) === -1) { s(new U("Unsupported protocol " + F + ":", U.ERR_BAD_REQUEST, e)); return } C.send(o || null) }) }, Wf = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let s = new AbortController, r; const o = function (d) { if (!r) { r = !0, c(); const a = d instanceof Error ? d : this.reason; s.abort(a instanceof U ? a : new zt(a instanceof Error ? a.message : a)) } }; let i = t && setTimeout(() => { i = null, o(new U(`timeout ${t} of ms exceeded`, U.ETIMEDOUT)) }, t); const c = () => { e && (i && clearTimeout(i), i = null, e.forEach(d => { d.unsubscribe ? d.unsubscribe(o) : d.removeEventListener("abort", o) }), e = null) }; e.forEach(d => d.addEventListener("abort", o)); const { signal: l } = s; return l.unsubscribe = () => h.asap(c), l } }, qf = function* (e, t) { let n = e.byteLength; if (n < t) { yield e; return } let s = 0, r; for (; s < n;)r = s + t, yield e.slice(s, r), s = r }, Jf = async function* (e, t) { for await (const n of zf(e)) yield* qf(n, t) }, zf = async function* (e) { if (e[Symbol.asyncIterator]) { yield* e; return } const t = e.getReader(); try { for (; ;) { const { done: n, value: s } = await t.read(); if (n) break; yield s } } finally { await t.cancel() } }, sc = (e, t, n, s) => { const r = Jf(e, t); let o = 0, i, c = l => { i || (i = !0, s && s(l)) }; return new ReadableStream({ async pull(l) { try { const { done: d, value: a } = await r.next(); if (d) { c(), l.close(); return } let f = a.byteLength; if (n) { let g = o += f; n(g) } l.enqueue(new Uint8Array(a)) } catch (d) { throw c(d), d } }, cancel(l) { return c(l), r.return() } }, { highWaterMark: 2 }) }, rc = 64 * 1024, { isFunction: ys } = h, Gf = (({ Request: e, Response: t }) => ({ Request: e, Response: t }))(h.global), { ReadableStream: oc, TextEncoder: ic } = h.global, cc = (e, ...t) => { try { return !!e(...t) } catch { return !1 } }, Xf = e => { e = h.merge.call({ skipUndefined: !0 }, Gf, e); const { fetch: t, Request: n, Response: s } = e, r = t ? ys(t) : typeof fetch == "function", o = ys(n), i = ys(s); if (!r) return !1; const c = r && ys(oc), l = r && (typeof ic == "function" ? (m => y => m.encode(y))(new ic) : async m => new Uint8Array(await new n(m).arrayBuffer())), d = o && c && cc(() => { let m = !1; const y = new n(ue.origin, { body: new oc, method: "POST", get duplex() { return m = !0, "half" } }).headers.has("Content-Type"); return m && !y }), a = i && c && cc(() => h.isReadableStream(new s("").body)), f = { stream: a && (m => m.body) }; r && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(m => { !f[m] && (f[m] = (y, C) => { let P = y && y[m]; if (P) return P.call(y); throw new U(`Response type '${m}' is not supported`, U.ERR_NOT_SUPPORT, C) }) }); const g = async m => { if (m == null) return 0; if (h.isBlob(m)) return m.size; if (h.isSpecCompliantForm(m)) return (await new n(ue.origin, { method: "POST", body: m }).arrayBuffer()).byteLength; if (h.isArrayBufferView(m) || h.isArrayBuffer(m)) return m.byteLength; if (h.isURLSearchParams(m) && (m = m + ""), h.isString(m)) return (await l(m)).byteLength }, O = async (m, y) => { const C = h.toFiniteNumber(m.getContentLength()); return C ?? g(y) }; return async m => { let { url: y, method: C, data: P, signal: F, cancelToken: V, timeout: J, onDownloadProgress: R, onUploadProgress: z, responseType: Z, headers: oe, withCredentials: ae = "same-origin", fetchOptions: Te } = nc(m), Be = t || fetch; Z = Z ? (Z + "").toLowerCase() : "text"; let fe = Wf([F, V && V.toAbortSignal()], J), Xe = null; const Ye = fe && fe.unsubscribe && (() => { fe.unsubscribe() }); let ke; try { if (z && d && C !== "get" && C !== "head" && (ke = await O(oe, P)) !== 0) { let _e = new n(y, { method: "POST", body: P, duplex: "half" }), De; if (h.isFormData(P) && (De = _e.headers.get("content-type")) && oe.setContentType(De), _e.body) { const [Re, yt] = Zi(ke, bs(Qi(z))); P = sc(_e.body, rc, Re, yt) } } h.isString(ae) || (ae = ae ? "include" : "omit"); const Q = o && "credentials" in n.prototype, B = { ...Te, signal: fe, method: C.toUpperCase(), headers: oe.normalize().toJSON(), body: P, duplex: "half", credentials: Q ? ae : void 0 }; Xe = o && new n(y, B); let L = await (o ? Be(Xe, Te) : Be(y, B)); const xe = a && (Z === "stream" || Z === "response"); if (a && (R || xe && Ye)) { const _e = {};["status", "statusText", "headers"].forEach(Ns => { _e[Ns] = L[Ns] }); const De = h.toFiniteNumber(L.headers.get("content-length")), [Re, yt] = R && Zi(De, bs(Qi(R), !0)) || []; L = new s(sc(L.body, rc, Re, () => { yt && yt(), Ye && Ye() }), _e) } Z = Z || "text"; let Sn = await f[h.findKey(f, Z) || "text"](L, m); return !xe && Ye && Ye(), await new Promise((_e, De) => { Yi(_e, De, { data: Sn, headers: ye.from(L.headers), status: L.status, statusText: L.statusText, config: m, request: Xe }) }) } catch (Q) { throw Ye && Ye(), Q && Q.name === "TypeError" && /Load failed|fetch/i.test(Q.message) ? Object.assign(new U("Network Error", U.ERR_NETWORK, m, Xe), { cause: Q.cause || Q }) : U.from(Q, Q && Q.code, m, Xe) } } }, Yf = new Map, lc = e => { let t = e && e.env || {}; const { fetch: n, Request: s, Response: r } = t, o = [s, r, n]; let i = o.length, c = i, l, d, a = Yf; for (; c--;)l = o[c], d = a.get(l), d === void 0 && a.set(l, d = c ? new Map : Xf(t)), a = d; return d }; lc(); const Sr = { http: yf, xhr: Kf, fetch: { get: lc } }; h.forEach(Sr, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch { } Object.defineProperty(e, "adapterName", { value: t }) } }); const ac = e => `- ${e}`, Zf = e => h.isFunction(e) || e === null || e === !1; function Qf(e, t) {
        e = h.isArray(e) ? e : [e]; const { length: n } = e; let s, r; const o = {}; for (let i = 0; i < n; i++) { s = e[i]; let c; if (r = s, !Zf(s) && (r = Sr[(c = String(s)).toLowerCase()], r === void 0)) throw new U(`Unknown adapter '${c}'`); if (r && (h.isFunction(r) || (r = r.get(t)))) break; o[c || "#" + i] = r } if (!r) {
            const i = Object.entries(o).map(([l, d]) => `adapter ${l} ` + (d === !1 ? "is not supported by the environment" : "is not available in the build")); let c = n ? i.length > 1 ? `since :
`+ i.map(ac).join(`
`) : " " + ac(i[0]) : "as no adapter specified"; throw new U("There is no suitable adapter to dispatch the request " + c, "ERR_NOT_SUPPORT")
        } return r
    } const uc = { getAdapter: Qf, adapters: Sr }; function xr(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new zt(null, e) } function fc(e) { return xr(e), e.headers = ye.from(e.headers), e.data = wr.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), uc.getAdapter(e.adapter || On.adapter, e)(e).then(function (s) { return xr(e), s.data = wr.call(e, e.transformResponse, s), s.headers = ye.from(s.headers), s }, function (s) { return Xi(s) || (xr(e), s && s.response && (s.response.data = wr.call(e, e.transformResponse, s.response), s.response.headers = ye.from(s.response.headers))), Promise.reject(s) }) } const dc = "1.13.2", _s = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { _s[e] = function (s) { return typeof s === e || "a" + (t < 1 ? "n " : " ") + e } }); const pc = {}; _s.transitional = function (t, n, s) { function r(o, i) { return "[Axios v" + dc + "] Transitional option '" + o + "'" + i + (s ? ". " + s : "") } return (o, i, c) => { if (t === !1) throw new U(r(i, " has been removed" + (n ? " in " + n : "")), U.ERR_DEPRECATED); return n && !pc[i] && (pc[i] = !0, console.warn(r(i, " has been deprecated since v" + n + " and will be removed in the near future"))), t ? t(o, i, c) : !0 } }, _s.spelling = function (t) { return (n, s) => (console.warn(`${s} is likely a misspelling of ${t}`), !0) }; function ed(e, t, n) { if (typeof e != "object") throw new U("options must be an object", U.ERR_BAD_OPTION_VALUE); const s = Object.keys(e); let r = s.length; for (; r-- > 0;) { const o = s[r], i = t[o]; if (i) { const c = e[o], l = c === void 0 || i(c, o, e); if (l !== !0) throw new U("option " + o + " must be " + l, U.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new U("Unknown option " + o, U.ERR_BAD_OPTION) } } const vs = { assertOptions: ed, validators: _s }, Ge = vs.validators; let Pt = class {
        constructor(t) { this.defaults = t || {}, this.interceptors = { request: new qi, response: new qi } } async request(t, n) {
            try { return await this._request(t, n) } catch (s) {
                if (s instanceof Error) {
                    let r = {}; Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error; const o = r.stack ? r.stack.replace(/^.+\n/, "") : ""; try {
                        s.stack ? o && !String(s.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (s.stack += `
`+ o) : s.stack = o
                    } catch { }
                } throw s
            }
        } _request(t, n) { typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = At(this.defaults, n); const { transitional: s, paramsSerializer: r, headers: o } = n; s !== void 0 && vs.assertOptions(s, { silentJSONParsing: Ge.transitional(Ge.boolean), forcedJSONParsing: Ge.transitional(Ge.boolean), clarifyTimeoutError: Ge.transitional(Ge.boolean) }, !1), r != null && (h.isFunction(r) ? n.paramsSerializer = { serialize: r } : vs.assertOptions(r, { encode: Ge.function, serialize: Ge.function }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), vs.assertOptions(n, { baseUrl: Ge.spelling("baseURL"), withXsrfToken: Ge.spelling("withXSRFToken") }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let i = o && h.merge(o.common, o[n.method]); o && h.forEach(["delete", "get", "head", "post", "put", "patch", "common"], m => { delete o[m] }), n.headers = ye.concat(i, o); const c = []; let l = !0; this.interceptors.request.forEach(function (y) { typeof y.runWhen == "function" && y.runWhen(n) === !1 || (l = l && y.synchronous, c.unshift(y.fulfilled, y.rejected)) }); const d = []; this.interceptors.response.forEach(function (y) { d.push(y.fulfilled, y.rejected) }); let a, f = 0, g; if (!l) { const m = [fc.bind(this), void 0]; for (m.unshift(...c), m.push(...d), g = m.length, a = Promise.resolve(n); f < g;)a = a.then(m[f++], m[f++]); return a } g = c.length; let O = n; for (; f < g;) { const m = c[f++], y = c[f++]; try { O = m(O) } catch (C) { y.call(this, C); break } } try { a = fc.call(this, O) } catch (m) { return Promise.reject(m) } for (f = 0, g = d.length; f < g;)a = a.then(d[f++], d[f++]); return a } getUri(t) { t = At(this.defaults, t); const n = ec(t.baseURL, t.url, t.allowAbsoluteUrls); return Wi(n, t.params, t.paramsSerializer) }
    }; h.forEach(["delete", "get", "head", "options"], function (t) { Pt.prototype[t] = function (n, s) { return this.request(At(s || {}, { method: t, url: n, data: (s || {}).data })) } }), h.forEach(["post", "put", "patch"], function (t) { function n(s) { return function (o, i, c) { return this.request(At(c || {}, { method: t, headers: s ? { "Content-Type": "multipart/form-data" } : {}, url: o, data: i })) } } Pt.prototype[t] = n(), Pt.prototype[t + "Form"] = n(!0) }); let td = class _c { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (o) { n = o }); const s = this; this.promise.then(r => { if (!s._listeners) return; let o = s._listeners.length; for (; o-- > 0;)s._listeners[o](r); s._listeners = null }), this.promise.then = r => { let o; const i = new Promise(c => { s.subscribe(c), o = c }).then(r); return i.cancel = function () { s.unsubscribe(o) }, i }, t(function (o, i, c) { s.reason || (s.reason = new zt(o, i, c), n(s.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const n = this._listeners.indexOf(t); n !== -1 && this._listeners.splice(n, 1) } toAbortSignal() { const t = new AbortController, n = s => { t.abort(s) }; return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal } static source() { let t; return { token: new _c(function (r) { t = r }), cancel: t } } }; function nd(e) { return function (n) { return e.apply(null, n) } } function sd(e) { return h.isObject(e) && e.isAxiosError === !0 } const Dr = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(Dr).forEach(([e, t]) => { Dr[t] = e }); function hc(e) { const t = new Pt(e), n = Ri(Pt.prototype.request, t); return h.extend(n, Pt.prototype, t, { allOwnKeys: !0 }), h.extend(n, t, null, { allOwnKeys: !0 }), n.create = function (r) { return hc(At(e, r)) }, n } const te = hc(On); te.Axios = Pt, te.CanceledError = zt, te.CancelToken = td, te.isCancel = Xi, te.VERSION = dc, te.toFormData = gs, te.AxiosError = U, te.Cancel = te.CanceledError, te.all = function (t) { return Promise.all(t) }, te.spread = nd, te.isAxiosError = sd, te.mergeConfig = At, te.AxiosHeaders = ye, te.formToJSON = e => zi(h.isHTMLForm(e) ? new FormData(e) : e), te.getAdapter = uc.getAdapter, te.HttpStatusCode = Dr, te.default = te; const { Axios: wd, AxiosError: Sd, CanceledError: xd, isCancel: Dd, CancelToken: Cd, VERSION: Td, all: Rd, Cancel: Vd, isAxiosError: Ad, spread: Pd, toFormData: Fd, AxiosHeaders: $d, HttpStatusCode: Id, formToJSON: Md, getAdapter: jd, mergeConfig: Ld } = te, rd = Ul({ name: "ChatWidget", props: { config: { type: Object, required: !0 } }, setup(e) { const t = jt(!1), n = jt([]), s = jt(""), r = jt(!1), o = jt(null), i = jt(null), c = Rt(() => e.config.baseUrl || window.location.origin), l = Rt(() => (e.config.position || "bottom-right") === "bottom-left" ? { left: "20px", right: "auto" } : { right: "20px", left: "auto" }), d = Rt(() => ({ backgroundColor: e.config.primaryColor || "#409EFF" })), a = Rt(() => ({ backgroundColor: e.config.primaryColor || "#409EFF" })), f = Rt(() => ({ borderColor: e.config.primaryColor || "#409EFF" })), g = Rt(() => ({ backgroundColor: e.config.primaryColor || "#409EFF" })), O = () => { t.value = !t.value, t.value && !o.value && y() }, m = () => { oo(() => { i.value && (i.value.scrollTop = i.value.scrollHeight) }) }, y = async () => { try { const P = await te.post(`${c.value}/api/agent/${e.config.agentId}/sessions`, { title: "Widget Chat" }, { headers: { "Content-Type": "application/json", "X-API-Key": e.config.apiKey } }); o.value = P.data.id } catch (P) { console.error("Failed to create session:", P), n.value.push({ role: "assistant", content: "" }) } }, C = async () => { if (!s.value.trim() || r.value || !o.value && (await y(), !o.value)) return; const P = s.value.trim(); s.value = "", n.value.push({ role: "user", content: P }), m(), r.value = !0; try { await te.post(`${c.value}/api/sessions/${o.value}/messages`, { role: "user", content: P, messageType: "text" }, { headers: { "Content-Type": "application/json", "X-API-Key": e.config.apiKey } }); const F = new EventSource(`${c.value}/nl2sql/chat/stream?sessionId=${o.value}&message=${encodeURIComponent(P)}`); let V = ""; F.onmessage = J => { try { const R = JSON.parse(J.data); if (R.type === "text" && R.content) { V += R.content; const z = n.value[n.value.length - 1]; z && z.role === "assistant" ? z.content = V : n.value.push({ role: "assistant", content: V }), m() } } catch (R) { console.error("Parse SSE error:", R) } }, F.onerror = () => { F.close(), r.value = !1, V || n.value.push({ role: "assistant", content: "" }), m() }, F.addEventListener("done", () => { F.close(), r.value = !1 }) } catch (F) { console.error("Send message error:", F), r.value = !1, n.value.push({ role: "assistant", content: "" }), m() } }; return Yn(() => n.value.length, () => { m() }), { isOpen: t, messages: n, userInput: s, isLoading: r, messagesContainer: i, positionStyle: l, buttonStyle: d, headerStyle: a, windowStyle: f, sendButtonStyle: g, toggleChat: O, sendMessage: C } } }), od = (e, t) => { const n = e.__vccOpts || e; for (const [s, r] of t) n[s] = r; return n }, id = { class: "chat-title" }, cd = { class: "chat-messages", ref: "messagesContainer" }, ld = { key: 0, class: "welcome-message" }, ad = { class: "message-content" }, ud = { key: 1, class: "message assistant" }, fd = { class: "chat-input" }, dd = ["disabled"], pd = ["disabled"]; function hd(e, t, n, s, r, o) { return gt(), Tt("div", { class: Zt(["chat-widget", { open: e.isOpen }]), style: dt(e.positionStyle) }, [e.isOpen ? ls("", !0) : (gt(), Tt("div", { key: 0, class: "chat-button", onClick: t[0] || (t[0] = (...i) => e.toggleChat && e.toggleChat(...i)), style: dt(e.buttonStyle) }, [...t[5] || (t[5] = [se("svg", { viewBox: "0 0 24 24", width: "24", height: "24", fill: "currentColor" }, [se("path", { d: "M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z" })], -1)])], 4)), e.isOpen ? (gt(), Tt("div", { key: 1, class: "chat-window", style: dt(e.windowStyle) }, [se("div", { class: "chat-header", style: dt(e.headerStyle) }, [se("div", id, Fn(e.config.title), 1), se("button", { class: "close-button", onClick: t[1] || (t[1] = (...i) => e.toggleChat && e.toggleChat(...i)) }, [...t[6] || (t[6] = [se("svg", { viewBox: "0 0 24 24", width: "20", height: "20", fill: "currentColor" }, [se("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })], -1)])])], 4), se("div", cd, [e.messages.length === 0 ? (gt(), Tt("div", ld, Fn(e.config.welcomeMessage), 1)) : ls("", !0), (gt(!0), Tt(Ce, null, ea(e.messages, (i, c) => (gt(), Tt("div", { key: c, class: Zt(["message", i.role]) }, [se("div", ad, Fn(i.content), 1)], 2))), 128)), e.isLoading ? (gt(), Tt("div", ud, [...t[7] || (t[7] = [se("div", { class: "message-content" }, [se("div", { class: "typing-indicator" }, [se("span"), se("span"), se("span")])], -1)])])) : ls("", !0)], 512), se("div", fd, [Al(se("input", { "onUpdate:modelValue": t[2] || (t[2] = i => e.userInput = i), type: "text", placeholder: "...", onKeypress: t[3] || (t[3] = Su((...i) => e.sendMessage && e.sendMessage(...i), ["enter"])), disabled: e.isLoading }, null, 40, dd), [[Ou, e.userInput]]), se("button", { onClick: t[4] || (t[4] = (...i) => e.sendMessage && e.sendMessage(...i)), disabled: !e.userInput.trim() || e.isLoading, style: dt(e.sendButtonStyle) }, [...t[8] || (t[8] = [se("svg", { viewBox: "0 0 24 24", width: "20", height: "20", fill: "currentColor" }, [se("path", { d: "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" })], -1)])], 12, pd)])], 4)) : ls("", !0)], 6) } const md = od(rd, [["render", hd], ["__scopeId", "data-v-4e31c220"]]); document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", mc) : mc(); function mc() { const e = window.DataAgentConfig; if (!e) { console.error("DataAgent Widget: Configuration not found. Please define window.DataAgentConfig before loading the widget."); return } if (!e.agentId || !e.apiKey) { console.error("DataAgent Widget: agentId and apiKey are required in configuration."); return } const t = document.createElement("div"); t.id = "data-agent-widget-container", document.body.appendChild(t), Cu(md, { config: { agentId: e.agentId, apiKey: e.apiKey, title: e.title || "AI ", position: e.position || "bottom-right", primaryColor: e.primaryColor || "#409EFF", welcomeMessage: e.welcomeMessage || " AI ", baseUrl: e.baseUrl } }).mount(t), console.log("DataAgent Widget initialized successfully") }
})();
