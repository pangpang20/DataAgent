/*
 * Copyright 2024-2026 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.audaque.cloud.ai.dataagent.workflow.node;

import static com.audaque.cloud.ai.dataagent.constant.Constant.PLAN_CURRENT_STEP;
import static com.audaque.cloud.ai.dataagent.constant.Constant.SQL_EXECUTE_NODE_OUTPUT;
import static com.audaque.cloud.ai.dataagent.constant.Constant.SQL_GENERATE_COUNT;
import static com.audaque.cloud.ai.dataagent.constant.Constant.SQL_GENERATE_OUTPUT;
import static com.audaque.cloud.ai.dataagent.constant.Constant.SQL_REGENERATE_REASON;
import static com.audaque.cloud.ai.dataagent.constant.Constant.SQL_RESULT_LIST_MEMORY;

import com.audaque.cloud.ai.dataagent.bo.DbConfigBO;
import com.audaque.cloud.ai.dataagent.bo.schema.DisplayStyleBO;
import com.audaque.cloud.ai.dataagent.bo.schema.ResultBO;
import com.audaque.cloud.ai.dataagent.bo.schema.ResultSetBO;
import com.audaque.cloud.ai.dataagent.connector.DbQueryParameter;
import com.audaque.cloud.ai.dataagent.connector.accessor.Accessor;
import com.audaque.cloud.ai.dataagent.constant.Constant;
import com.audaque.cloud.ai.dataagent.dto.datasource.SqlRetryDto;
import com.audaque.cloud.ai.dataagent.dto.planner.ExecutionStep;
import com.audaque.cloud.ai.dataagent.enums.TextType;
import com.audaque.cloud.ai.dataagent.prompt.PromptLoader;
import com.audaque.cloud.ai.dataagent.properties.DataAgentProperties;
import com.audaque.cloud.ai.dataagent.service.llm.LlmService;
import com.audaque.cloud.ai.dataagent.service.nl2sql.Nl2SqlService;
import com.audaque.cloud.ai.dataagent.util.ChatResponseUtil;
import com.audaque.cloud.ai.dataagent.util.DatabaseUtil;
import com.audaque.cloud.ai.dataagent.util.FluxUtil;
import com.audaque.cloud.ai.dataagent.util.JsonUtil;
import com.audaque.cloud.ai.dataagent.util.MarkdownParserUtil;
import com.audaque.cloud.ai.dataagent.util.PlanProcessUtil;
import com.audaque.cloud.ai.dataagent.util.StateUtil;
import com.alibaba.cloud.ai.graph.GraphResponse;
import com.alibaba.cloud.ai.graph.OverAllState;
import com.alibaba.cloud.ai.graph.action.NodeAction;
import com.alibaba.cloud.ai.graph.streaming.StreamingOutput;
import java.time.Duration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;

/**
 * SQL execution node that executes SQL queries against the database.
 *
 * This node is responsible for: - Executing SQL queries generated by previous
 * nodes -
 * Handling query results and errors - Providing streaming feedback to users
 * during
 * execution - Managing step-by-step result accumulation
 *
 */
@Slf4j
@Component
@AllArgsConstructor
public class SqlExecuteNode implements NodeAction {

	private final DatabaseUtil databaseUtil;

	private final Nl2SqlService nl2SqlService;

	private final LlmService llmService;

	private final DataAgentProperties properties;

	private static final int SAMPLE_DATA_NUMBER = 20;

	@Override
	public Map<String, Object> apply(OverAllState state) throws Exception {

		Integer currentStep = PlanProcessUtil.getCurrentStepNumber(state);

		String sqlQuery = StateUtil.getStringValue(state, SQL_GENERATE_OUTPUT);
		log.debug("[SqlExecuteNode] Raw SQL from state (before trim): [{}]", sqlQuery);
		log.debug("[SqlExecuteNode] Raw SQL length: {}, isEmpty: {}",
				sqlQuery != null ? sqlQuery.length() : "null",
				sqlQuery == null ? "null" : sqlQuery.isEmpty());

		sqlQuery = nl2SqlService.sqlTrim(sqlQuery);

		log.debug("[SqlExecuteNode] SQL after trim: [{}]", sqlQuery);
		log.debug("[SqlExecuteNode] SQL after trim length: {}, isEmpty: {}",
				sqlQuery != null ? sqlQuery.length() : "null",
				sqlQuery == null ? "null" : sqlQuery.isEmpty());
		log.info("Executing SQL query: `{}`", sqlQuery);

		// Get the agent ID from the state
		String agentIdStr = StateUtil.getStringValue(state, Constant.AGENT_ID);
		log.debug("[SqlExecuteNode] Agent ID from state: {}", agentIdStr);
		if (agentIdStr == null || agentIdStr.trim().isEmpty()) {
			throw new IllegalStateException("Agent ID cannot be empty.");
		}

		Integer agentId = Integer.valueOf(agentIdStr);
		log.debug("[SqlExecuteNode] Current step: {}, Agent ID: {}", currentStep, agentId);

		// Dynamically get the data source configuration for an agent
		DbConfigBO dbConfig = databaseUtil.getAgentDbConfig(agentId);
		log.debug("[SqlExecuteNode] DB config retrieved: url={}, schema={}, dialectType={}",
				dbConfig.getUrl(), dbConfig.getSchema(), dbConfig.getDialectType());

		return executeSqlQuery(state, currentStep, sqlQuery, dbConfig, agentId);
	}

	/**
	 * Executes the SQL query against the database and handles the results.
	 *
	 * This method follows the business-logic-first pattern: 1. Execute the actual
	 * SQL
	 * query immediately 2. Process and store the results 3. Create streaming output
	 * for
	 * user experience only
	 * 
	 * @param state       The overall state containing execution context
	 * @param currentStep The current step number in the execution plan
	 * @param sqlQuery    The SQL query to execute
	 * @param dbConfig    The database configuration to use for execution
	 * @param agentId     The agent ID
	 * @return Map containing the generator for streaming output
	 */
	@SuppressWarnings("unchecked")
	private Map<String, Object> executeSqlQuery(OverAllState state, Integer currentStep, String sqlQuery,
			DbConfigBO dbConfig, Integer agentId) {
		log.debug("[SqlExecuteNode] Entering executeSqlQuery - step: {}, agentId: {}", currentStep, agentId);
		log.debug("[SqlExecuteNode] SQL to execute: `{}`", sqlQuery);

		// Execute business logic first - actual SQL execution
		DbQueryParameter dbQueryParameter = new DbQueryParameter();
		dbQueryParameter.setSql(sqlQuery);
		dbQueryParameter.setSchema(dbConfig.getSchema());
		log.debug("[SqlExecuteNode] DbQueryParameter created with schema: {}", dbConfig.getSchema());

		Accessor dbAccessor = databaseUtil.getAgentAccessor(agentId);
		log.debug("[SqlExecuteNode] DB accessor obtained: {}", dbAccessor.getClass().getSimpleName());
		final Map<String, Object> result = new HashMap<>();

		// 先返回流式数据，在执行数据库查询
		Flux<ChatResponse> displayFlux = Flux.create(emitter -> {
			log.debug("[SqlExecuteNode] Starting streaming output emission");
			emitter.next(ChatResponseUtil.createResponse("开始执行SQL..."));
			emitter.next(ChatResponseUtil.createResponse("执行SQL查询："));
			emitter.next(ChatResponseUtil.createPureResponse(TextType.SQL.getStartSign()));
			emitter.next(ChatResponseUtil.createResponse(sqlQuery));
			emitter.next(ChatResponseUtil.createPureResponse(TextType.SQL.getEndSign()));
			ResultBO resultBO = ResultBO.builder().build();

			try {
				log.debug("[SqlExecuteNode] Executing SQL via accessor: {}", sqlQuery);
				log.debug("[SqlExecuteNode] DB config: url={}, schema={}", dbConfig.getUrl(), dbConfig.getSchema());
				// Execute SQL query and get results immediately
				ResultSetBO resultSetBO = dbAccessor.executeSqlAndReturnObject(dbConfig, dbQueryParameter);
				log.debug("[SqlExecuteNode] SQL execution successful, result set obtained");
				log.debug("[SqlExecuteNode] Result columns: {}", resultSetBO.getColumn());
				log.debug("[SqlExecuteNode] Result data size: {}",
						resultSetBO.getData() != null ? resultSetBO.getData().size() : "null");
				// 调用大模型获取图表配置信息并填充到ResultSetBO中
				log.debug("[SqlExecuteNode] Enriching result with chart config");
				DisplayStyleBO displayStyleBO = enrichResultSetWithChartConfig(state, resultSetBO);
				log.debug("[SqlExecuteNode] Chart config enrichment completed, display type: {}",
						displayStyleBO != null ? displayStyleBO.getType() : "null");
				resultBO.setResultSet(resultSetBO);
				resultBO.setDisplayStyle(displayStyleBO);

				String strResultSetJson = JsonUtil.getObjectMapper().writeValueAsString(resultSetBO);
				String strResultJson = JsonUtil.getObjectMapper().writeValueAsString(resultBO);
				log.debug("[SqlExecuteNode] Result JSON length: {}", strResultJson.length());

				// 数据执行成功
				emitter.next(ChatResponseUtil.createResponse("执行SQL完成"));
				emitter.next(ChatResponseUtil.createResponse("SQL查询结果："));
				emitter.next(ChatResponseUtil.createPureResponse(TextType.RESULT_SET.getStartSign()));
				emitter.next(ChatResponseUtil.createPureResponse(strResultJson));
				emitter.next(ChatResponseUtil.createPureResponse(TextType.RESULT_SET.getEndSign()));

				// Update step results with the query output
				Map<String, String> existingResults = StateUtil.getObjectValue(state, SQL_EXECUTE_NODE_OUTPUT,
						Map.class, new HashMap<>());
				Map<String, String> updatedResults = PlanProcessUtil.addStepResult(existingResults, currentStep,
						strResultSetJson);

				log.info("SQL execution successful, result count: {}",
						resultSetBO.getData() != null ? resultSetBO.getData().size() : 0);

				// 回写最终执行的sql，报告节点需要使用
				ExecutionStep.ToolParameters currentStepParams = PlanProcessUtil.getCurrentExecutionStep(state)
						.getToolParameters();
				currentStepParams.setSqlQuery(sqlQuery);
				log.debug("[SqlExecuteNode] SQL written back to current step params");

				// Prepare the final result object
				// Store List of SQL query results for use by code execution node
				// Reset sql generate count retry times when sql execute success
				result.putAll(Map.of(SQL_EXECUTE_NODE_OUTPUT, updatedResults, SQL_REGENERATE_REASON,
						SqlRetryDto.empty(), SQL_RESULT_LIST_MEMORY, resultSetBO.getData(), PLAN_CURRENT_STEP,
						currentStep + 1, SQL_GENERATE_COUNT, 0));
				log.debug("[SqlExecuteNode] Result map prepared, next step: {}", currentStep + 1);
			} catch (Exception e) {
				String errorMessage = e.getMessage();
				log.error("[SqlExecuteNode] SQL execution failed - SQL as follows: \n`{}`\n", sqlQuery, e);
				log.error("[SqlExecuteNode] Error type: {}, Error message: {}",
						e.getClass().getSimpleName(), errorMessage);
				log.debug("[SqlExecuteNode] DB config used: url={}, schema={}, dialectType={}",
						dbConfig.getUrl(), dbConfig.getSchema(), dbConfig.getDialectType());
				result.put(SQL_REGENERATE_REASON, SqlRetryDto.sqlExecute(errorMessage));
				log.debug("[SqlExecuteNode] SqlRetryDto created with error message");
				emitter.next(ChatResponseUtil.createResponse("SQL执行失败: " + errorMessage));
			} finally {
				log.debug("[SqlExecuteNode] Completing streaming output emission");
				emitter.complete();
			}
		});

		// Create generator using utility class, returning pre-computed business logic
		// result
		Flux<GraphResponse<StreamingOutput>> generator = FluxUtil.createStreamingGeneratorWithMessages(this.getClass(),
				state, v -> result, displayFlux);
		log.debug("[SqlExecuteNode] Streaming generator created, returning result map");

		return Map.of(SQL_EXECUTE_NODE_OUTPUT, generator);
	}

	/**
	 * 调用大模型获取图表配置信息并填充到ResultSetBO中
	 * 
	 * @param state       整体状态
	 * @param resultSetBO SQL执行结果
	 */
	private DisplayStyleBO enrichResultSetWithChartConfig(OverAllState state, ResultSetBO resultSetBO) {
		log.debug("[SqlExecuteNode] Entering enrichResultSetWithChartConfig");
		// 创建ResultDisplayStyleBO对象
		DisplayStyleBO displayStyle = new DisplayStyleBO();
		if (!this.properties.isEnableSqlResultChart()) {
			log.debug("[SqlExecuteNode] SQL result chart is disabled, set display style as table default");
			displayStyle.setType("table");
			return displayStyle;
		}
		log.debug("[SqlExecuteNode] Chart enrichment enabled, proceeding with LLM call");

		try {
			// 获取用户查询
			String userQuery = StateUtil.getCanonicalQuery(state);
			log.debug("[SqlExecuteNode] User query for chart config: {}", userQuery);

			// 将SQL结果转换为JSON字符串，限制数据量以避免提示词过长
			String sqlResultJson = JsonUtil.getObjectMapper()
					.writeValueAsString(resultSetBO.getData() != null
							? resultSetBO.getData().stream().limit(SAMPLE_DATA_NUMBER).toList()
							: null);
			log.debug("[SqlExecuteNode] Sample data JSON length: {} (limited to {} rows)",
					sqlResultJson.length(), SAMPLE_DATA_NUMBER);

			// 构建用户提示词，包含SQL结果数据
			String userPrompt = String.format("""
					# 正式任务

					<最新>用户输入: %s
					范例数据: %s

					# 输出
					""", userQuery != null ? userQuery : "数据可视化", sqlResultJson);

			// 加载data-view-analyze提示词模板（系统提示词）
			String fullPrompt = PromptLoader.loadPrompt("data-view-analyze");
			// 分割系统提示词和用户提示词模板
			String[] parts = fullPrompt.split("=== 用户输入 ===", 2);
			// 渲染系统提示词（当前没有变量，直接使用模板内容）
			String systemPrompt = parts[0].trim();

			log.debug("Built chart config generation system prompt as follows \n {} \n", systemPrompt);
			log.debug("Built chart config generation user prompt as follows \n {} \n", userPrompt);

			// 调用LLM生成图表配置（使用系统提示词和用户提示词）
			log.debug("[SqlExecuteNode] Calling LLM for chart config generation");
			String chartConfigJson = llmService.toStringFlux(llmService.call(systemPrompt, userPrompt))
					.collect(StringBuilder::new, StringBuilder::append)
					.map(StringBuilder::toString)
					.block(Duration.ofMillis(properties.getEnrichSqlResultTimeout()));
			log.debug("[SqlExecuteNode] LLM returned chart config, length: {}",
					chartConfigJson != null ? chartConfigJson.length() : "null");

			if (chartConfigJson != null && !chartConfigJson.trim().isEmpty()) {
				log.debug("[SqlExecuteNode] Raw chart config from LLM: [{}]", chartConfigJson.trim());
				String content = MarkdownParserUtil.extractText(chartConfigJson.trim());
				log.debug("[SqlExecuteNode] Extracted chart config content: [{}]", content);
				// Clean up escape characters that LLM may have incorrectly added
				// e.g., \{"type":"bar"...\} -> {"type":"bar"...}
				if (content != null) {
					content = content.replace("\\\\", "").replace("\\{", "{").replace("\\}", "}");
					log.debug("[SqlExecuteNode] Chart config after escape cleanup: [{}]", content);
				}
				// Parse JSON and fill into ResultSetBO
				Map<String, Object> chartConfig = JsonUtil.getObjectMapper().readValue(content, Map.class);

				// 提取图表配置信息并设置到ResultDisplayStyleBO
				if (chartConfig.containsKey("type")) {
					displayStyle.setType((String) chartConfig.get("type"));
				} else {
					displayStyle.setType("table");
				}
				if (chartConfig.containsKey("title")) {
					displayStyle.setTitle((String) chartConfig.get("title"));
				}
				if (chartConfig.containsKey("x")) {
					displayStyle.setX((String) chartConfig.get("x"));
				}
				if (chartConfig.containsKey("y")) {
					Object yValue = chartConfig.get("y");
					if (yValue instanceof String) {
						String yStr = (String) yValue;
						// 将逗号分隔的字符串转换为列表
						displayStyle.setY(java.util.Arrays.asList(yStr.split(",")));
					} else if (yValue instanceof List) {
						displayStyle.setY((List<String>) yValue);
					}
				}
				log.debug(
						"[SqlExecuteNode] Successfully enriched ResultSetBO with chart config: type={}, title={}, x={}, y={}",
						displayStyle.getType(), displayStyle.getTitle(), displayStyle.getX(), displayStyle.getY());
				return displayStyle;
			} else {
				log.warn("[SqlExecuteNode] LLM returned empty chart config, using default settings");
			}
		} catch (Exception e) {
			log.error("[SqlExecuteNode] Failed to enrich ResultSetBO with chart config: {}", e.getMessage(), e);
			// 不抛出异常，允许流程继续执行
		}
		log.debug("[SqlExecuteNode] Returning null display style");
		return null;
	}

}
